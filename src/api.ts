/* tslint:disable */
/* eslint-disable */
/**
 * Tangocrypto API
 * ## Overview  Tangocrypto API(Application Programing Interface) allows you fast and reliable access to the Cardano network that requires only minutes to integrate.    ## API Key header   When you sign up on https://www.tangocrypto.com and create an App an `x-api-key` is created. You must include the HTTP header `x-api-key` in every request in order to authenticate the API calls.   ## Network and Account ID   You can choose the mainnet or the testnet for your queries. The API requires a valid `app_id` to be included with your request traffic. This identifier should be appended to the request URL.   <table>    <tr><td><b>Network</b></td><td><b>Endpoint</b></td></tr>    <tr><td>Cardano mainnet</td><td><tt>https://cardano-mainnet.tangocrypto.com/{app_id}/v1</td></tt></tr>    <tr><td>Cardano testnet</td><td><tt>https://cardano-testnet.tangocrypto.com/{app_id}/v1</tt></td></tr>  </table>   ## Errors   ### HTTP Status codes   These are the response codes you are going to get when you query Tangocrypto API.   <table>    <tr><td><b>Code</b></td><td><b>Meaning</b></td></tr>    <tr><td><tt><strong>400</strong></tt></td><td><strong>Bad Request</strong> - Your request is invalid. </td></tr>    <tr><td><tt><strong>401</strong></tt></td><td><strong>Unauthorized</strong> - You must authenticate your request with an API key. Check out how to create a key if you do not have one. </td></tr>    <tr><td><tt><strong>403</strong></tt></td><td><strong>Forbidden</strong> - Check you are using the right API KEY, or you\'ve hit your capacity limit, or your request was rejected by your app\'s whitelist settings. </td></tr>    <tr><td><tt><strong>404</strong></tt></td><td><strong>Not found</strong> - Endpoint not found. </td></tr>    <tr><td><tt><strong>429</strong></tt></td><td><strong>Too Many Requests</strong> - You\'ve exceeded your concurrent requests capacity. Check out the Rate Limits page for solutions.</td></tr>    <tr><td><tt><strong>500</strong></tt></td><td><strong>Internal Server Error</strong> - We\'re unable to process your request right now. Get in touch with us if you see this.</td></tr>  </table>  
 *
 * The version of the OpenAPI document: 1
 * Contact: contact@tangocrypto.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, buildPath, ApiPromise } from './common';
// @ts-ignore
import { BASE_PATH, RequestArgs, BaseAPI } from './base';

/**
 * 
 * @export
 * @interface AffiliateSummary
 */
export interface AffiliateSummary {
    /**
     * Affiliate id
     * @type {string}
     * @memberof AffiliateSummary
     */
    'id'?: string;
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof AffiliateSummary
     */
    'name'?: string;
    /**
     * The value is `true` if the affiliate is active and `false` if it is not.
     * @type {boolean}
     * @memberof AffiliateSummary
     */
    'active'?: boolean;
    /**
     * If set to `true`, the funds are transferred automatically to the affiliate every time a customer purchases an NFT.
     * @type {boolean}
     * @memberof AffiliateSummary
     */
    'automatic_payout'?: boolean;
    /**
     * The wallet address of the affiliate. The revenue made from the affiliate sales goes to this address.
     * @type {string}
     * @memberof AffiliateSummary
     */
    'address'?: string;
    /**
     * The total amount of ADA generated by the sale. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {number}
     * @memberof AffiliateSummary
     */
    'revenue'?: number;
    /**
     * Income made by the affiliate from the sale. This is the amount of Ada (in Lovelaces) that goes to the affiliate wallet. For example, if the affiliate sells a package of 4 NFTs for 40 Ada and the commission rate is 20% the income will be 8000000 Lovelaces.
     * @type {number}
     * @memberof AffiliateSummary
     */
    'income'?: number;
    /**
     * Commission rate made by the affiliate. If the `commision_type` is `flat` here, you have to specify the commission in Lovelaces. If the commission_type is set to `percentage`, then here you type the percentage. For example, 0.2 represents 20%.
     * @type {number}
     * @memberof AffiliateSummary
     */
    'commission'?: number;
    /**
     * There are two types of commission types, `fla`t and `percentage`. Use `flat` commission if you want to pay a flat rate on every sale. For example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the commission is set to 10 Ada, the affiliate will receive 10 Ada. Use percentage commission if you want to pay a percentage on every sale; for example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the 1commission1 is set to 20% the affiliate will receive 20 Ada.
     * @type {string}
     * @memberof AffiliateSummary
     */
    'commission_type'?: string;
    /**
     * Amount of sales made by the affiliate.
     * @type {number}
     * @memberof AffiliateSummary
     */
    'sale_count'?: number;
}
/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'policy_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'asset_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'quantity'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Asset
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BuildTxRequest
 */
export interface BuildTxRequest {
    /**
     * 
     * @type {Array<BuildTxRequestInputsInner>}
     * @memberof BuildTxRequest
     */
    'inputs'?: Array<BuildTxRequestInputsInner>;
    /**
     * 
     * @type {Array<BuildTxRequestInputsInner>}
     * @memberof BuildTxRequest
     */
    'outputs'?: Array<BuildTxRequestOutputsInner>;
    /**
     * 
     * @type {{ [key: string]: Array<Asset>; }}
     * @memberof BuildTxRequest
     */
    'recipients'?: { [key: string]: Array<Asset>; };
    /**
     * 
     * @type {BuildTxRequestMintingScript}
     * @memberof BuildTxRequest
     */
    'minting_script'?: BuildTxRequestMintingScript;
    /**
     * 
     * @type {string}
     * @memberof BuildTxRequest
     */
    'change_address'?: string;
}
/**
 * 
 * @export
 * @interface BuildTxRequestInputsInner
 */
export interface BuildTxRequestInputsInner {
    /**
     * 
     * @type {string}
     * @memberof BuildTxRequestInputsInner
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildTxRequestInputsInner
     */
    'hash'?: string;
    /**
     * 
     * @type {number}
     * @memberof BuildTxRequestInputsInner
     */
    'index'?: number;
    /**
     * 
     * @type {number}
     * @memberof BuildTxRequestInputsInner
     */
    'value'?: number;
    /**
     * 
     * @type {Array<Asset>}
     * @memberof BuildTxRequestInputsInner
     */
    'assets'?: Array<Asset>;
}
/**
 * 
 * @export
 * @interface BuildTxRequestInputsInner
 */
export interface BuildTxRequestOutputsInner {
    /**
     * 
     * @type {string}
     * @memberof BuildTxRequestOutputsInner
     */
    'address': string;

    /**
     * 
     * @type {number}
     * @memberof BuildTxRequestOutputsInner
     */
    'value': number;
    /**
     * 
     * @type {Array<Asset>}
     * @memberof BuildTxRequestOutputsInner
     */
    'assets'?: Array<Asset>;
}
/**
 * 
 * @export
 * @interface BuildTxRequestMintingScript
 */
export interface BuildTxRequestMintingScript {
    /**
     * 
     * @type {string}
     * @memberof BuildTxRequestMintingScript
     */
    'type'?: string;
    /**
     * 
     * @type {Array<BuildTxRequestMintingScriptScriptsInner>}
     * @memberof BuildTxRequestMintingScript
     */
    'scripts'?: Array<BuildTxRequestMintingScriptScriptsInner>;
}
/**
 * 
 * @export
 * @interface BuildTxRequestMintingScriptScriptsInner
 */
export interface BuildTxRequestMintingScriptScriptsInner {
    /**
     * 
     * @type {string}
     * @memberof BuildTxRequestMintingScriptScriptsInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildTxRequestMintingScriptScriptsInner
     */
    'keyHash'?: string;
    /**
     * 
     * @type {number}
     * @memberof BuildTxRequestMintingScriptScriptsInner
     */
    'slot'?: number;
}
/**
 * 
 * @export
 * @interface BuildTxResponse
 */
export interface BuildTxResponse {
    /**
     * 
     * @type {string}
     * @memberof BuildTxResponse
     */
    'tx_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildTxResponse
     */
    'tx'?: string;
}
/**
 * 
 * @export
 * @interface CancelNftSaleResponse
 */
export interface CancelNftSaleResponse {
    /**
     * Return `true` if the sale was canceled succesfully.
     * @type {boolean}
     * @memberof CancelNftSaleResponse
     */
    'canceled'?: boolean;
    /**
     * Cancelled sale id.
     * @type {string}
     * @memberof CancelNftSaleResponse
     */
    'canceled_sale_id'?: string;
    /**
     * Cancelation timestamp.
     * @type {string}
     * @memberof CancelNftSaleResponse
     */
    'canceled_at'?: string;
}
/**
 * 
 * @export
 * @interface CheckAddressListRequest
 */
export interface CheckAddressListRequest {
    /**
     * Bech32 address.
     * @type {string}
     * @memberof CheckAddressListRequest
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface CollectionDeleteResponse
 */
export interface CollectionDeleteResponse {
    /**
     * Returns `true` if successfuly deleted or `false` if there was an error deleting the collection.
     * @type {boolean}
     * @memberof CollectionDeleteResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted collection ID.
     * @type {string}
     * @memberof CollectionDeleteResponse
     */
    'deleted_collection_id'?: string;
    /**
     * Deletion datetime in ISO 8601 format.
     * @type {string}
     * @memberof CollectionDeleteResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateAddressListResponse
 */
export interface CreateAddressListResponse {
    /**
     * Address list id.
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'name'?: string;
    /**
     * Address list name.
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'description'?: string;
    /**
     * Size in bytes.
     * @type {number}
     * @memberof CreateAddressListResponse
     */
    'size'?: number;
    /**
     * Number of items.
     * @type {number}
     * @memberof CreateAddressListResponse
     */
    'items'?: number;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateAffiliateRequest
 */
export interface CreateAffiliateRequest {
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof CreateAffiliateRequest
     */
    'name': string;
    /**
     * The value is `true` if the affiliate is active and `false` if it is not.
     * @type {boolean}
     * @memberof CreateAffiliateRequest
     */
    'active'?: boolean;
    /**
     * If set to `true`, the funds are transferred automatically to the affiliate every time a customer purchases an NFT.
     * @type {boolean}
     * @memberof CreateAffiliateRequest
     */
    'automatic_payout'?: boolean;
    /**
     * The wallet address of the affiliate. The revenue made from the affiliate sales goes to this address.
     * @type {string}
     * @memberof CreateAffiliateRequest
     */
    'address': string;
    /**
     * Commission rate made by the affiliate. If the `commision_type` is `flat` here, you have to specify the commission in Lovelaces. If the `commission_type` is set to `percentage`, then here you type the percentage. For example, 0.2 represents 20%.
     * @type {number}
     * @memberof CreateAffiliateRequest
     */
    'commission': number;
    /**
     * There are two types of commission types, `flat` and `percentage`. Use `flat` commission if you want to pay a flat rate on every sale. For example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the `commission` is set to 10 Ada, the affiliate will receive 10 Ada.  Use `percentage` commission if you want to pay a percentage on every sale; for example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the 1commission1 is set to 20% the affiliate will receive 20 Ada.
     * @type {string}
     * @memberof CreateAffiliateRequest
     */
    'commission_type': CreateAffiliateRequestCommissionTypeEnum;
}
/**
 * 
 * @export
 * @interface UpdateAffiliateRequest
 */
export interface UpdateAffiliateRequest {
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof UpdateAffiliateRequest
     */
    'name'?: string;
    /**
     * The value is `true` if the affiliate is active and `false` if it is not.
     * @type {boolean}
     * @memberof UpdateAffiliateRequest
     */
    'active'?: boolean;
    /**
     * If set to `true`, the funds are transferred automatically to the affiliate every time a customer purchases an NFT.
     * @type {boolean}
     * @memberof UpdateAffiliateRequest
     */
    'automatic_payout'?: boolean;
}

/**
 * 
 * @export
 * @interface CreatePriceTierRequest
 */
export interface CreatePriceTierRequest {
    /**
     * Price tier name. Used to identify the price tier.
     * @type {string}
     * @memberof CreatePriceTierRequest
     */
    'name': string;
    /**
     * Price tier price. How much paid for buying with this price tier.
     * @type {number}
     * @memberof CreatePriceTierRequest
     */
    'price': number;
    /**
     * Price tier quantity. How many tokens will be sold with this price tier.
     * NOTE: Cannot create sales with more than 20 tokens
     * @type {number}
     * @memberof CreatePriceTierRequest
     */
    'quantity': number;
    /**
     * Price tier supply. Amount of token supply when minted, default to 1.
     * @type {number}
     * @memberof CreatePriceTierRequest
     */
    'supply'?: number;
    /**
     * Price tier tokens. Individual tokens to include in a price tier.
     * NOTE: Tokens batch size must be less than or equal to 20
     * @type {Array<number>}
     * @memberof CreatePriceTierRequest
     */
    'tokens'?: Array<string>;
}

/**
 * 
 * @export
 * @interface CreatePriceTierResponse
 */
export interface CreatePriceTierResponse {
    /**
     * Price Tier id.
     * @type {string}
     * @memberof CreatePriceTierResponse
     */
    id: string;
    /**
     * Price Tier name.
     * @type {string}
     * @memberof CreatePriceTierResponse
     */
    name: string;
    /**
     * Price Tier price.
     * @type {number}
     * @memberof CreatePriceTierResponse
     */
    price: number;
    /**
     * Price Tier quantity.
     * @type {number}
     * @memberof CreatePriceTierResponse
     */
    quantity: number;
    /**
     * Price Tier supply.
     * @type {number}
     * @memberof CreatePriceTierResponse
     */
    supply: number;
    /**
     * Price Tier tokens.
     * @type {Array<string>}
     * @memberof CreatePriceTierResponse
     */
    tokens: Array<string>;
    /**
     * Price Tier token sold count.
     * @type {number}
     * @memberof CreatePriceTierResponse
     */
    token_sold_count: number;
}

/**
* 
* @export
* @interface UpdatePriceTierRequest
*/
export interface UpdatePriceTierRequest {
    /**
     * Price tier name. Used to identify the price tier.
     * @type {string}
     * @memberof UpdatePriceTierRequest
     */
    'name'?: string;
    /**
     * Price tier price. How much paid for buying with this price tier.
     * @type {number}
     * @memberof UpdatePriceTierRequest
     */
    'price'?: number;
    /**
     * Price tier quantity. How many tokens will be sold with this price tier. 
     * NOTE: Cannot create sales with more than 20 tokens
     * @type {number}
     * @memberof UpdatePriceTierRequest
     */
    'quantity'?: number;
    /**
     * Price tier supply. Amount of token supply when minted, default to 1.
     * @type {number}
     * @memberof UpdatePriceTierRequest
     */
    'supply'?: number;
    /**
     * Price tier tokens. Individual tokens to include in a price tier.
     * NOTE: Tokens batch size must be less than or equal to 20     
     * @type {Array<number>}
     * @memberof UpdatePriceTierRequest
     */
    'tokens'?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdatePriceTierResponse
 */
export interface UpdatePriceTierResponse {
    /**
     * Price Tier id.
     * @type {string}
     * @memberof UpdatePriceTierResponse
     */
    id: string;
    /**
     * Price Tier name.
     * @type {string}
     * @memberof UpdatePriceTierResponse
     */
    name: string;
    /**
     * Price Tier price.
     * @type {number}
     * @memberof UpdatePriceTierResponse
     */
    price: number;
    /**
     * Price Tier quantity.
     * @type {number}
     * @memberof UpdatePriceTierResponse
     */
    quantity: number;
    /**
     * Price Tier supply.
     * @type {number}
     * @memberof UpdatePriceTierResponse
     */
    supply: number;
    /**
     * Price Tier tokens.
     * @type {Array<string>}
     * @memberof UpdatePriceTierResponse
     */
    tokens: Array<string>;
    /**
     * Price Tier token sold count.
     * @type {number}
     * @memberof UpdatePriceTierResponse
     */
    token_sold_count: number;
}


/**
 * 
 * @export
 * @interface DeletePriceTierResponse
 */
export interface DeletePriceTierResponse {
    /**
     * Returns `true` if successfuly deleted or `false` if there was an error deleting the price tier.
     * @type {boolean}
     * @memberof DeletePriceTierResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted price tier ID
     * @type {string}
     * @memberof DeletePriceTierResponse
     */
    'deleted_affiliate_id'?: string;
    /**
     * Deletion datetime in ISO 8601 format.
     * @type {string}
     * @memberof DeletePriceTierResponse
     */
    'deleted_at'?: string;
}

export const CreateAffiliateRequestCommissionTypeEnum = {
    Flat: 'flat',
    Percentage: 'percentage'
} as const;

export type CreateAffiliateRequestCommissionTypeEnum = typeof CreateAffiliateRequestCommissionTypeEnum[keyof typeof CreateAffiliateRequestCommissionTypeEnum];

/**
 * 
 * @export
 * @interface CreateAffiliateResponse
 */
export interface CreateAffiliateResponse {
    /**
     * affiliate id
     * @type {string}
     * @memberof CreateAffiliateResponse
     */
    'id'?: string;
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof CreateAffiliateResponse
     */
    'name'?: string;
    /**
     * The value is `true` if the affiliate is active and `false` if it is not.
     * @type {boolean}
     * @memberof CreateAffiliateResponse
     */
    'active'?: boolean;
    /**
     * If set to `true`, the funds are transferred automatically to the affiliate every time a customer purchases an NFT.
     * @type {boolean}
     * @memberof CreateAffiliateResponse
     */
    'automatic_payout'?: boolean;
    /**
     * The wallet address of the affiliate. The revenue made from the affiliate sales goes to this address.
     * @type {string}
     * @memberof CreateAffiliateResponse
     */
    'address'?: string;
    /**
     * The total amount of ADA generated by the sale. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {number}
     * @memberof CreateAffiliateResponse
     */
    'revenue'?: number;
    /**
     * Income made by the affiliate from the sale. This is the amount of Ada (in Lovelaces) that goes to the affiliate wallet. For example, if the affiliate sells a package of 4 NFTs for 40 Ada and the commission rate is 20% the income will be 8000000 Lovelaces.
     * @type {number}
     * @memberof CreateAffiliateResponse
     */
    'income'?: number;
    /**
     * Commission rate made by the affiliate. If the `commision_type` is `flat` here, you have to specify the commission in Lovelaces. If the `commission_type` is set to `percentage`, then here you type the percentage. For example, 0.2 represents 20%.
     * @type {number}
     * @memberof CreateAffiliateResponse
     */
    'commission'?: number;
    /**
     * There are two types of commission types, `flat` and `percentag`e. Use `flat` commission if you want to pay a flat rate on every sale. For example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the `commission` is set to 10 Ada, the affiliate will receive 10 Ada.  Use `percentage` commission if you want to pay a percentage on every sale; for example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the 1commission1 is set to 20% the affiliate will receive 20 Ada.
     * @type {string}
     * @memberof CreateAffiliateResponse
     */
    'commission_type'?: string;
    /**
     * Amount of sales made by the affiliate.
     * @type {number}
     * @memberof CreateAffiliateResponse
     */
    'sale_count'?: number;
}
/**
 * Create NFT Collection request
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * Collection name. The collection name is internal to your Tangocrypto account. This is just a way to identify different collections.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'name': string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'url'?: string;
    /**
     * 
     * @type {CreateCollectionRequestPayoutAddress}
     * @memberof CreateCollectionRequest
     */
    'payout_address': CreateCollectionRequestPayoutAddress;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    'reservation_time'?: number;
    /**
     * 
     * @type {CreateCollectionRequestPolicy}
     * @memberof CreateCollectionRequest
     */
    'policy': CreateCollectionRequestPolicy;
    /**
     * 
     * @type {CreateCollectionRequestMetadata}
     * @memberof CreateCollectionRequest
     */
    'metadata'?: CreateCollectionRequestMetadata;
    /**
     * 
     * @type {CreateCollectionRequestRoyalty}
     * @memberof CreateCollectionRequest
     */
    'royalty'?: CreateCollectionRequestRoyalty;
}
/**
 * Metadata tags for the collection. The values between `< >` mean that they are tags. A tag is simply a variable that we will assign its value when you mint the NFT. You can use the metadata tag to define common attributes shared by all the NFTs in the collection, like the name, copyright, date issued, artist name, social media links, etc. Using metadata tags is not mandatory because you can define all the attributes while creating the individual NFTs. For more details about Metadata have a look at the CIP (https://cips.cardano.org/cips/cip25/) 
 * @export
 * @interface CreateCollectionRequestMetadata
 */
export interface CreateCollectionRequestMetadata {
    /**
     * Metadata tag for the NFT asset name.
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'asset_name'?: string;
    /**
     * Metadata tag for the file name.
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'name': string;
    /**
     * Metadata tag for the NFT description.
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'description'?: string;
    /**
     * Metadata tag for the media type (also known as a Multipurpose Internet Mail Extensions or MIME type) indicates the nature and format of a document, file, or assortment of bytes. It is common to have NFTs with MIME-type imag, audio and video.
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'media_type'?: string;
    /**
     * Array of files used for files. This is used when you want to create an NFT with different file formats. For example, you can create several audio files and add them to the metadata.
     * @type {Array<CreateCollectionRequestMetadataFilesInner>}
     * @memberof CreateCollectionRequestMetadata
     */
    'files'?: Array<CreateCollectionRequestMetadataFilesInner>;
    /**
     * Custom attributes or traits for an NFT. You can create 2 types of attributes, fixed or variables.  <br /> **Fixed**: We include these attributes in the metadata of every NFT minted in the collection with a fixed value. You can add attributes like artist name, Twitter, Discord, copyright etc. You define their value here, and then you don\'t have to submit them during the NFT creation step.  <br /> **Variables**: Here you define a tag, which means that we\'ll replace this tag with a value you\'ll have to provide during the NFT creation step. As you can see in the example, we defined five traits (colour, body, eyes, face, and accesory), but we don\'t specify the value, just a tag between the angle brackets`<>`. 
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'attributes'?: string;
    /**
     * Metadata version
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface CreateCollectionRequestMetadataFilesInner
 */
export interface CreateCollectionRequestMetadataFilesInner {
    /**
     * Asset name of the file
     * @type {string}
     * @memberof CreateCollectionRequestMetadataFilesInner
     */
    'name'?: string;
    /**
     * Metadata tag for the media type.
     * @type {string}
     * @memberof CreateCollectionRequestMetadataFilesInner
     */
    'media_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionRequestMetadataFilesInner
     */
    'src'?: string;
}
/**
 * @type CreateCollectionRequestPayoutAddress
 * @export
 */
export type CreateCollectionRequestPayoutAddress = Array<NftCollectionPayoutAddressOneOfInner> | string;

/**
 * Policy configuration for every NFT in the collection. When you create a new collection we do several steps in the background; we create a new key pair (*public verification key/private signing key*), a *policy script* and the *policy id*. Then during the sale process, all the tokens are minted with the same *policy script* and the *policy id* is attached permanently to the NFT.  
 * @export
 * @interface CreateCollectionRequestPolicy
 */
export interface CreateCollectionRequestPolicy {
    /**
     * Defines if the policy will be locked or not. If you select `false` then you are not required to chose a date and time to lock the policy, therefore the policy will be open and you can be minting NFTs under this policy forever. If you set this parameter to `true` then you have to specify a `locktime` date. 
     * @type {boolean}
     * @memberof CreateCollectionRequestPolicy
     */
    'lock': CreateCollectionRequestPolicyLockEnum;
    /**
     * Locktime date in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. It defines how long you\'ll be able to mint NFTs for the collection. The policy will lock after that date, and you won\'t be able to mint more NFTs using the same policy id (even if you use the same key). Hours and minutes are optional; if you set it to `2022-02-24`, it will automatically fill it with 0s, for example, `2022-02-24T00:00:00.000Z`. Take into consideration the desirability and size of your collection before setting this date and leave enough time for selling the NFTs. There is no limited time for the future. 
     * @type {string}
     * @memberof CreateCollectionRequestPolicy
     */
    'lock_time'?: string;
}

export const CreateCollectionRequestPolicyLockEnum = {
    True: true,
    False: false
} as const;

export type CreateCollectionRequestPolicyLockEnum = typeof CreateCollectionRequestPolicyLockEnum[keyof typeof CreateCollectionRequestPolicyLockEnum];

/**
 * 
 * @export
 * @interface CreateCollectionRequestRoyalty
 */
export interface CreateCollectionRequestRoyalty {
    /**
     * Bech32 address split in a two-element array. Each element in the array must have up to 64 bytes.
     * @type {Array<string>}
     * @memberof CreateCollectionRequestRoyalty
     */
    'address'?: Array<string>;
    /**
     * Percentage of the sale price earned each time your NFT creation is sold on a marketplace. For example, 0.05 represents 5%.
     * @type {number}
     * @memberof CreateCollectionRequestRoyalty
     */
    'rate'?: number;
}
/**
 * NFT Collection
 * @export
 * @interface CreateCollectionResponse
 */
export interface CreateCollectionResponse {
    /**
     * Collection ID.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'id'?: string;
    /**
     * Collection name.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'name'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'url'?: string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'description'?: string;
    /**
     * Wallet address that is going to receive the payments of the NFT sale.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'payout_address'?: string;
    /**
     * Amount of tokens in the collection.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'token_count'?: number;
    /**
     * Amount of tokens for sale.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'token_for_sale_count'?: number;
    /**
     * Amount of tokens sold.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'token_sold_count'?: number;
    /**
     * The total amount of ADA generated by the sale of NFTs in the collection. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'revenue'?: number;
    /**
     * The total amount of ADA generated by the sale of NFTs that goest to the seller.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'income'?: number;
    /**
     * Tangocrypto service fee. This fee depends on your plan and the number of NFTs minted. Check the price page to get more information about it.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'service_fee'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'nft_fee'?: number;
    /**
     * Transaction fees.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent in fees. This includes transaction fees, nft fees and the service fees.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'total_fees'?: number;
    /**
     * 
     * @type {NftCollectionPolicy}
     * @memberof CreateCollectionResponse
     */
    'policy'?: NftCollectionPolicy;
    /**
     * 
     * @type {NftCollectionMetadata}
     * @memberof CreateCollectionResponse
     */
    'metadata'?: NftCollectionMetadata;
    /**
     * 
     * @type {CreateCollectionResponseRoyalty}
     * @memberof CreateCollectionResponse
     */
    'royalty'?: CreateCollectionResponseRoyalty;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponseRoyalty
 */
export interface CreateCollectionResponseRoyalty {
    /**
     * 
     * @type {CreateCollectionResponseRoyaltyMetadata}
     * @memberof CreateCollectionResponseRoyalty
     */
    'metadata'?: CreateCollectionResponseRoyaltyMetadata;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponseRoyaltyMetadata
 */
export interface CreateCollectionResponseRoyaltyMetadata {
    /**
     * 
     * @type {CreateCollectionResponseRoyaltyMetadata777}
     * @memberof CreateCollectionResponseRoyaltyMetadata
     */
    '777'?: CreateCollectionResponseRoyaltyMetadata777;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponseRoyaltyMetadata777
 */
export interface CreateCollectionResponseRoyaltyMetadata777 {
    /**
     * Bech32 address split in a two-element array. Each element in the array must have up to 64 bytes.
     * @type {Array<string>}
     * @memberof CreateCollectionResponseRoyaltyMetadata777
     */
    'addr'?: Array<string>;
    /**
     * Percentage of the sale price earned each time your NFT creation is sold on a marketplace. For example, 0.05 represents 5%.
     * @type {number}
     * @memberof CreateCollectionResponseRoyaltyMetadata777
     */
    'rate'?: number;
}
/**
 * Token request
 * @export
 * @interface CreateNftRequest
 */
export interface CreateNftRequest {
    /**
     * Array of tokens. You can upload a maximum of 25 tokens in a single request.
     * @type {Array<CreateNftRequestTokensInner>}
     * @memberof CreateNftRequest
     */
    'tokens': Array<CreateNftRequestTokensInner>;
}
/**
 * 
 * @export
 * @interface CreateNftRequestTokensInner
 */
export interface CreateNftRequestTokensInner {
    /**
     * Asset name. Take into consideration is the name is case sensitive and is between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof CreateNftRequestTokensInner
     */
    'asset_name': string;
    /**
     * Display name. Between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof CreateNftRequestTokensInner
     */
    'name': string;
    /**
     * Token description. Between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof CreateNftRequestTokensInner
     */
    'description'?: string;
    /**
     * (Optional) Individual NFT price in Lovelace (1 ADA = 1000000 Lovelace). This parameter is used for flash minting when you don\'t want to create Sale Phases or Sales and want to make a quick sale.
     * @type {number}
     * @memberof CreateNftRequestTokensInner
     */
    'price'?: number;
    /**
     * Media type. For example you can use `image/jpeg`, `image/png`, `image/gif`, `video/mp4`.
     * @type {string}
     * @memberof CreateNftRequestTokensInner
     */
    'media_type'?: string;
    /**
     * 
     * @type {CreateNftRequestTokensInnerImage}
     * @memberof CreateNftRequestTokensInner
     */
    'image': CreateNftRequestTokensInnerImage;
    /**
     * You have to specify the values for the tag attributes for every token as defined in the collection attribute tag definition when you create the collection. Please take into consideration that we have to define these values for every single NFT in the collection. For example, we set the colour, body, eyes, face and mime type for that particular NFT.For more details about Metadata have a look at the CIP (https://cips.cardano.org/cips/cip25/)
     * @type {Array<CreateNftRequestTokensInnerMetadataAttributesInner>}
     * @memberof CreateNftRequestTokensInner
     */
    'metadata_attributes'?: Array<CreateNftRequestTokensInnerMetadataAttributesInner>;
    /**
     * Here you can set any arbitrary attributes that you didn\'t include in the collection attributes tag definition. Use `\"key\":\"value\"` pairs to define unique attributes for each NFT.
     * @type {object}
     * @memberof CreateNftRequestTokensInner
     */
    'custom_attributes'?: object;
}
/**
 * @type CreateNftRequestTokensInnerImage
 * base64 encoded image.
 * @export
 */
export type CreateNftRequestTokensInnerImage = Array<string> | string;

/**
 * 
 * @export
 * @interface CreateNftRequestTokensInnerMetadataAttributesInner
 */
export interface CreateNftRequestTokensInnerMetadataAttributesInner {
    /**
     * Use the `tag` to match the tag defined in the collection.
     * @type {string}
     * @memberof CreateNftRequestTokensInnerMetadataAttributesInner
     */
    'tag'?: string;
    /**
     * Use the `value` to set a value for the tag `tag`.
     * @type {string}
     * @memberof CreateNftRequestTokensInnerMetadataAttributesInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface CreateNftResponse
 */
export interface CreateNftResponse {
    /**
     * 
     * @type {Array<NftToken>}
     * @memberof CreateNftResponse
     */
    'data'?: Array<NftToken>;
    /**
     * 
     * @type {number}
     * @memberof CreateNftResponse
     */
    'status_code'?: number;
}
/**
 * 
 * @export
 * @interface CreateNftSaleRequest
 */
export interface CreateNftSaleRequest {
    /**
     * <br /> Use `fixed` for selling a particular token or token list identified by the token-id.  <br /> Use `random` for random sales, it will pick random tokens from the collection.\' 
     * @type {string}
     * @memberof CreateNftSaleRequest
     */
    'type': CreateNftSaleRequestTypeEnum;
    /**
     * Individual NFT price in Lovelace (1 ADA = 1000000 Lovelace).
     * @type {number}
     * @memberof CreateNftSaleRequest
     */
    'price': number;
    /**
     * Reservation time in *seconds*. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, the NFT will be ready for sale again, and another buyer can reserve it.
     * @type {number}
     * @memberof CreateNftSaleRequest
     */
    'reservation_time': number;
    /**
     * An array of the token ids of the NFTs you want to sell. This field is required only for `fixed` sales. If you use `ramdom` sale you should omit this field.
     * @type {Array<string>}
     * @memberof CreateNftSaleRequest
     */
    'tokens'?: Array<string>;
    /**
     * Amount of tokens to sell.
     * @type {number}
     * @memberof CreateNftSaleRequest
     */
    'quantity'?: number;
}

export const CreateNftSaleRequestTypeEnum = {
    Fixed: 'fixed',
    Random: 'random'
} as const;

export type CreateNftSaleRequestTypeEnum = typeof CreateNftSaleRequestTypeEnum[keyof typeof CreateNftSaleRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateNftSaleResponse
 */
export interface CreateNftSaleResponse {
    /**
     * Sale id. This gives you a way to identify a particular sale. Every time you generate a sale you\'ll get a new sale id.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'id'?: string;
    /**
     * NFT status
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'status'?: CreateNftSaleResponseStatusEnum;
    /**
     * Use `fixed` for selling a particular token or token list identified by the token-id. Use `random` for random sales, it will pick random tokens from the collection.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'type'?: CreateNftSaleResponseTypeEnum;
    /**
     * Individual token price in Lovelace (1 ADA = 1000000 Lovelace).
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'price'?: number;
    /**
     * Number of tokens for sale. 1 for NFTs.
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'supply'?: number;
    /**
     * Address where the customer has to make the payment.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'payment_address'?: string;
    /**
     * Reservation time in ms. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received, and this timer expires then the NFT is ready for sale again and it can be reserved by another buyer.
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'reserved_time'?: number;
    /**
     * Payment URL. This is the URL you add to your website as a link or a button to buy the NFTs. You can think about this URL as your payment button.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'payment_link'?: string;
    /**
     * Tangocrypto fee per NFT minted.
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'service_fee'?: number;
    /**
     * Array of NFTs. The metadata is shown with the same format that is minted.
     * @type {Array<object>}
     * @memberof CreateNftSaleResponse
     */
    'tokens'?: Array<object>;
    /**
     * number of confirmations.
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'confirmations'?: number;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'updated_at'?: string;
}

export const CreateNftSaleResponseStatusEnum = {
    UploadingContent: 'UPLOADING_CONTENT',
    ForSale: 'FOR_SALE',
    Reserved: 'RESERVED',
    Completed: 'COMPLETED'
} as const;

export type CreateNftSaleResponseStatusEnum = typeof CreateNftSaleResponseStatusEnum[keyof typeof CreateNftSaleResponseStatusEnum];
export const CreateNftSaleResponseTypeEnum = {
    Fixed: 'fixed',
    Random: 'random'
} as const;

export type CreateNftSaleResponseTypeEnum = typeof CreateNftSaleResponseTypeEnum[keyof typeof CreateNftSaleResponseTypeEnum];

/**
 * 
 * @export
 * @interface CreatePriceTierItem
 */
export interface CreatePriceTierItem {
    /**
     * Price tier ID.
     * @type {string}
     * @memberof CreatePriceTierItem
     */
    'id'?: string;
    /**
     * Price tier name
     * @type {string}
     * @memberof CreatePriceTierItem
     */
    'name'?: string;
    /**
     * Price (in Lovelaces) for the tier. For example, you can create a price tier with amount 5 and price 50. That means the buyer is going to pay 50 ADA for 5 NFTs.
     * @type {number}
     * @memberof CreatePriceTierItem
     */
    'price'?: number;
    /**
     * Amount of tokens to mint in a price tier. For example, you can specify that buyers selecting the bronze price tier will mint 1 token and the buyers choosing the silver price tier will mint 5 tokens.
     * @type {number}
     * @memberof CreatePriceTierItem
     */
    'count'?: number;
    /**
     * Token supply. If you don\'\'t specify the supply, it will be set to 1 by default.
     * @type {number}
     * @memberof CreatePriceTierItem
     */
    'supply'?: number;
    /**
     * Amount of tokens sold with the price tier.
     * @type {number}
     * @memberof CreatePriceTierItem
     */
    'token_sold_count'?: number;
    /**
     * Payment URL. This is the URL you add to your website as a link or a button to buy the NFTs. You can think about this URL as your payment button.
     * @type {string}
     * @memberof CreatePriceTierItem
     */
    'payment_link'?: string;
}

/**
 * 
 * @export
 * @interface CreateSalePhaseRequest
 */
export interface CreateSalePhaseRequest {
    /**
     * Sale phase name. For example, pre-sale.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'name'?: string;
    /**
     * <br /> Use `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> Use `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'type': CreateSalePhaseRequestTypeEnum;
    /**
     * Sale active. 
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'active'?: boolean;
    /**
     * Defines how many NFTs you will sell in this phase. For example, you are doing a pre-sale, and you want to sell 1000 NFTs.
     * @type {number}
     * @memberof CreateSalePhaseRequest
     */
    'total_tokens': number;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {number}
     * @memberof CreateSalePhaseRequest
     */
    'reservation_time'?: number;
    /**
     * Starting date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don\'t provide this value you can start selling immediately.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'start_date'?: string;
    /**
     * Ending date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don\'t provide this value, there is no time boundary; thus, you can sell NFTs until you reach the collection\'s total amount.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'end_date'?: string;
    /**
     * (Used in `random` sale phases). Create price tiers per sale phase. A price tier is a way to create bundles and sell them for different prices. For example, you can create a price tier with 10 NFTs for 100 ADA, and the buyer will pay 100 ADA and receive 10 NFTs in their wallet. You can create up to 10 price tiers per sale phase.\'
     * @type {Array<CreateSalePhaseRequestPriceTiersInner>}
     * @memberof CreateSalePhaseRequest
     */
    'price_tiers'?: Array<CreateSalePhaseRequestPriceTiersInner>;
    /**
     * (Used in `fixed` sale phases). Individual tokens to include in a sale phase.
     * @type {Array<CreateSalePhaseRequestTokensInner>}
     * @memberof CreateSalePhaseRequest
     */
    'tokens'?: Array<CreateSalePhaseRequestTokensInner>;
}

/**
 * 
 * @export
 * @interface UpdateSalePhaseRequest
 */
export interface UpdateSalePhaseRequest {
    /**
     * Sale phase name. For example, pre-sale.
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'name'?: string;
    /**
     * <br /> Use `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> Use `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'type'?: CreateSalePhaseRequestTypeEnum;
    /**
     * Sale active. 
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'active'?: boolean;
    /**
     * Defines how many NFTs you will sell in this phase. For example, you are doing a pre-sale, and you want to sell 1000 NFTs.
     * @type {number}
     * @memberof UpdateSalePhaseRequest
     */
    'total_tokens': number;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {number}
     * @memberof UpdateSalePhaseRequest
     */
    'reservation_time'?: number;
    /**
     * Starting date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don\'t provide this value you can start selling immediately.
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'start_date'?: string;
    /**
     * Ending date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don\'t provide this value, there is no time boundary; thus, you can sell NFTs until you reach the collection\'s total amount.
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'end_date'?: string;
    /**
     * (Used in `random` sale phases). Create price tiers per sale phase. A price tier is a way to create bundles and sell them for different prices. For example, you can create a price tier with 10 NFTs for 100 ADA, and the buyer will pay 100 ADA and receive 10 NFTs in their wallet. You can create up to 10 price tiers per sale phase.\'
     * @type {Array<CreateSalePhaseRequestPriceTiersInner>}
     * @memberof UpdateSalePhaseRequest
     */
    'price_tiers'?: Array<CreateSalePhaseRequestPriceTiersInner>;
    /**
     * (Used in `fixed` sale phases). Individual tokens to include in a sale phase.
     * @type {Array<CreateSalePhaseRequestTokensInner>}
     * @memberof UpdateSalePhaseRequest
     */
    'tokens'?: Array<CreateSalePhaseRequestTokensInner>;
}

export const CreateSalePhaseRequestTypeEnum = {
    Fixed: 'fixed',
    Random: 'random'
} as const;

export type CreateSalePhaseRequestTypeEnum = typeof CreateSalePhaseRequestTypeEnum[keyof typeof CreateSalePhaseRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateSalePhaseRequestPriceTiersInner
 */
export interface CreateSalePhaseRequestPriceTiersInner {
    /**
     * Price tier name. You can name your price tiers within a sale phase.
     * @type {string}
     * @memberof CreateSalePhaseRequestPriceTiersInner
     */
    'name'?: string;
    /**
     * Amount of tokens to mint in a price tier. For example, you can specify that buyers selecting the bronze price tier will mint 1 token and the buyers choosing the silver price tier will mint a bundle with 5 tokens. You can create a price tier with a maximum of 100 tokens.
     * @type {number}
     * @memberof CreateSalePhaseRequestPriceTiersInner
     */
    'quantity': number;
    /**
     * Token supply. If you don\'\'t specify the supply, it will be set to 1 by default.
     * @type {number}
     * @memberof CreateSalePhaseRequestPriceTiersInner
     */
    'supply'?: number;
    /**
     * Price (in Lovelaces) for the tier. For example, you can create a price tier with amount 5 and price 50. That means the buyer is going to pay 50 ADA for 5 NFTs.
     * @type {number}
     * @memberof CreateSalePhaseRequestPriceTiersInner
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface CreateSalePhaseRequestTokensInner
 */
export interface CreateSalePhaseRequestTokensInner {
    /**
     * Token id. This id is returned when you create the tokens.
     * @type {string}
     * @memberof CreateSalePhaseRequestTokensInner
     */
    'id': string;
    /**
     * Token supply. If you don\'\'t specify the supply, it will be set to 1 by default.
     * @type {number}
     * @memberof CreateSalePhaseRequestTokensInner
     */
    'supply'?: number;
    /**
     * Price (in Lovelaces) for the token.
     * @type {number}
     * @memberof CreateSalePhaseRequestTokensInner
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface CreateSalePhaseResponse
 */
export interface CreateSalePhaseResponse {
    /**
     * Sale phase ID. Use this ID to identify different phases.
     * @type {string}
     * @memberof CreateSalePhaseResponse
     */
    'id'?: string;
    /**
     * <br /> `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof CreateSalePhaseResponse
     */
    'type'?: string;
    /**
     * True if the sale phase is active, false if is not active.
     * @type {boolean}
     * @memberof CreateSalePhaseResponse
     */
    'active'?: boolean;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {number}
     * @memberof CreateSalePhaseResponse
     */
    'reservation_time'?: number;
    /**
     * Total amount of tokens for sell in the phase.
     * @type {number}
     * @memberof CreateSalePhaseResponse
     */
    'total_tokens'?: number;
    /**
     * Remaining tokens for sale.
     * @type {number}
     * @memberof CreateSalePhaseResponse
     */
    'remaining_tokens'?: number;
    /**
     * 
     * @type {Array<CreatePriceTierItem>}
     * @memberof CreateSalePhaseResponse
     */
    'price_tiers'?: Array<CreatePriceTierItem>;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateSalePhaseResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateSalePhaseResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
    /**
     * Webhook name
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'name': string;
    /**
     * Blockchain network
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'network': CreateWebhookRequestNetworkEnum;
    /**
     * Webhook description
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'description'?: string;
    /**
     * Webhook type
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'type': CreateWebhookRequestTypeEnum;
    /**
     * Destination address. This field is used only in the payment webhook and it\'s mandatory in payment webhooks.
     * @type {any}
     * @memberof CreateWebhookRequest
     */
    'address'?: any;
    /**
     * The URL where your server is listening. We send a POST to this URL with the webhook event.
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'callback_url': string;
    /**
     * Every rule is composed of a field, a value and an operator. All the conditions have to be met for the webhook to be triggered. Rules are optional; depending on the number of rules and their parameters, the webhook will be triggered or not.
     * @type {Array<CreateWebhookRequestRulesInner>}
     * @memberof CreateWebhookRequest
     */
    'rules'?: Array<CreateWebhookRequestRulesInner>;
}

export const CreateWebhookRequestNetworkEnum = {
    Mainnet: 'mainnet',
    Testnet: 'testnet'
} as const;

export type CreateWebhookRequestNetworkEnum = typeof CreateWebhookRequestNetworkEnum[keyof typeof CreateWebhookRequestNetworkEnum];
export const CreateWebhookRequestTypeEnum = {
    Payment: 'payment',
    Transaction: 'transaction',
    Block: 'block',
    Delegation: 'delegation',
    Epoch: 'epoch',
    Asset: 'asset',
    NftApi: 'nft_api'
} as const;

export type CreateWebhookRequestTypeEnum = typeof CreateWebhookRequestTypeEnum[keyof typeof CreateWebhookRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateWebhookRequestRulesInner
 */
export interface CreateWebhookRequestRulesInner {
    /**
     * Depends on the type of webhook it can be `policy_id`, `asset_name`, `fingerprint`, `ammount`, etc. For a full reference vist <a href=\"https://docs.tangocrypto.com/notify/notify/trigger-rules\">Trigger Rules</a>.
     * @type {string}
     * @memberof CreateWebhookRequestRulesInner
     */
    'field'?: string;
    /**
     * Depending on the field it can be `=`, `>`, `<`, `>=`, `<=`\'. For a full reference vist <a href=\"https://docs.tangocrypto.com/notify/notify/trigger-rules\">Trigger Rules</a>.
     * @type {string}
     * @memberof CreateWebhookRequestRulesInner
     */
    'operator'?: string;
    /**
     * The `value` value depends on the type of webhook. For a full reference vist <a href=\"https://docs.tangocrypto.com/notify/notify/trigger-rules\">Trigger Rules</a>.
     * @type {string}
     * @memberof CreateWebhookRequestRulesInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface CreateWebhooksResponse
 */
export interface CreateWebhooksResponse {
    /**
     * Webhook ID
     * @type {string}
     * @memberof CreateWebhooksResponse
     */
    'id'?: string;
    /**
     * Webhook type
     * @type {string}
     * @memberof CreateWebhooksResponse
     */
    'type'?: string;
    /**
     * Webhook name
     * @type {string}
     * @memberof CreateWebhooksResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhooksResponse
     */
    'network'?: string;
    /**
     * Webhook description
     * @type {string}
     * @memberof CreateWebhooksResponse
     */
    'description'?: string;
    /**
     * Destination address.
     * @type {any}
     * @memberof CreateWebhooksResponse
     */
    'address'?: any;
    /**
     * The URL where your server is listening. We send a POST to this URL with the webhook event.
     * @type {string}
     * @memberof CreateWebhooksResponse
     */
    'callback_url'?: string;
    /**
     * Every rule is composed of a field, a value and an operator.  
     * @type {Array<RetrieveWebhookResponseRulesInner>}
     * @memberof CreateWebhooksResponse
     */
    'rules'?: Array<RetrieveWebhookResponseRulesInner>;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateWebhooksResponse
     */
    'create_date'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateWebhooksResponse
     */
    'update_date'?: string;
    /**
     * True if the webhook is available. False if the webhook is disabled.
     * @type {boolean}
     * @memberof CreateWebhooksResponse
     */
    'available'?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteAddressListResponse
 */
export interface DeleteAddressListResponse {
    /**
     * Returns `true` if was succesfully deleted or `false` if there was an error.
     * @type {boolean}
     * @memberof DeleteAddressListResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted address list id
     * @type {string}
     * @memberof DeleteAddressListResponse
     */
    'deleted_phase_id'?: string;
    /**
     * Timestamp of this deletion in ISO 8601 format.
     * @type {string}
     * @memberof DeleteAddressListResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface DeleteAffiliateResponse
 */
export interface DeleteAffiliateResponse {
    /**
     * Returns `true` if successfuly deleted or `false` if there was an error deleting the affiliate.
     * @type {boolean}
     * @memberof DeleteAffiliateResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted affiliate ID
     * @type {string}
     * @memberof DeleteAffiliateResponse
     */
    'deleted_affiliate_id'?: string;
    /**
     * Deletion datetime in ISO 8601 format.
     * @type {string}
     * @memberof DeleteAffiliateResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface DeleteNftResponse
 */
export interface DeleteNftResponse {
    /**
     * Returns `true` if successfuly deleted or `false` if there was an error deleting the token.
     * @type {boolean}
     * @memberof DeleteNftResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted token ID
     * @type {string}
     * @memberof DeleteNftResponse
     */
    'deleted_token_id'?: string;
    /**
     * Deletion datetime in ISO 8601 format.
     * @type {string}
     * @memberof DeleteNftResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface DeleteSalePhaseResponse
 */
export interface DeleteSalePhaseResponse {
    /**
     * Returns `true` if was succesfully deleted or `false` if there was an error.
     * @type {boolean}
     * @memberof DeleteSalePhaseResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted sale phase id
     * @type {string}
     * @memberof DeleteSalePhaseResponse
     */
    'deleted_phase_id'?: string;
    /**
     * Timestamp of this deletion in ISO 8601 format.
     * @type {string}
     * @memberof DeleteSalePhaseResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface DeleteWebhookResponse
 */
export interface DeleteWebhookResponse {
    /**
     * True if was succesfully deleted. False if there was an error.
     * @type {boolean}
     * @memberof DeleteWebhookResponse
     */
    'deleted'?: boolean;
    /**
     * The ID of the deleted webhook
     * @type {string}
     * @memberof DeleteWebhookResponse
     */
    'deleted_webhook_id'?: string;
    /**
     * The database timestamp of this deletion in ISO 8601 format.
     * @type {string}
     * @memberof DeleteWebhookResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface GetAddressSummary400Response
 */
export interface GetAddressSummary400Response {
    /**
     * 
     * @type {number}
     * @memberof GetAddressSummary400Response
     */
    'status_code': number;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary400Response
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary400Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetAddressSummary401Response
 */
export interface GetAddressSummary401Response {
    /**
     * 
     * @type {number}
     * @memberof GetAddressSummary401Response
     */
    'status_code': number;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary401Response
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary401Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetAddressSummary403Response
 */
export interface GetAddressSummary403Response {
    /**
     * 
     * @type {number}
     * @memberof GetAddressSummary403Response
     */
    'status_code': number;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary403Response
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary403Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetAddressSummary404Response
 */
export interface GetAddressSummary404Response {
    /**
     * 
     * @type {number}
     * @memberof GetAddressSummary404Response
     */
    'status_code': number;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary404Response
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary404Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetAddressSummary429Response
 */
export interface GetAddressSummary429Response {
    /**
     * 
     * @type {number}
     * @memberof GetAddressSummary429Response
     */
    'status_code': number;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary429Response
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary429Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetAddressSummary500Response
 */
export interface GetAddressSummary500Response {
    /**
     * 
     * @type {number}
     * @memberof GetAddressSummary500Response
     */
    'status_code': number;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary500Response
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressSummary500Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ListAddressAssetsResponse
 */
export interface ListAddressAssetsResponse {
    /**
     * 
     * @type {Array<ListAddressAssetsResponseDataInner>}
     * @memberof ListAddressAssetsResponse
     */
    'data'?: Array<ListAddressAssetsResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListAddressAssetsResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListAddressAssetsResponseDataInner
 */
export interface ListAddressAssetsResponseDataInner {
    /**
     * Policy ID controlling an asset
     * @type {string}
     * @memberof ListAddressAssetsResponseDataInner
     */
    'policy_id'?: string;
    /**
     * Asset name
     * @type {string}
     * @memberof ListAddressAssetsResponseDataInner
     */
    'asset_name'?: string;
    /**
     * Asset fingerprint (<a href=\"https://cips.cardano.org/cips/cip14/\">CIP14</a>)
     * @type {string}
     * @memberof ListAddressAssetsResponseDataInner
     */
    'fingerprint'?: string;
    /**
     * Assset quantity
     * @type {string}
     * @memberof ListAddressAssetsResponseDataInner
     */
    'quantity'?: string;
}
/**
 * 
 * @export
 * @interface ListAddressTransactionsResponse
 */
export interface ListAddressTransactionsResponse {
    /**
     * 
     * @type {Array<ListAddressTransactionsResponseDataInner>}
     * @memberof ListAddressTransactionsResponse
     */
    'data'?: Array<ListAddressTransactionsResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListAddressTransactionsResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListAddressTransactionsResponseDataInner
 */
export interface ListAddressTransactionsResponseDataInner {
    /**
     * Transaction hash.
     * @type {string}
     * @memberof ListAddressTransactionsResponseDataInner
     */
    'hash'?: string;
    /**
     * Transaction total output sum in Lovelace (1 Ada == 1000000 Lovelace).
     * @type {string}
     * @memberof ListAddressTransactionsResponseDataInner
     */
    'out_sum'?: string;
    /**
     * Transaction fee in Lovelace (1 Ada == 1000000 Lovelace).
     * @type {string}
     * @memberof ListAddressTransactionsResponseDataInner
     */
    'fee'?: string;
    /**
     * 
     * @type {ListAddressTransactionsResponseDataInnerBlock}
     * @memberof ListAddressTransactionsResponseDataInner
     */
    'block'?: ListAddressTransactionsResponseDataInnerBlock;
    /**
     * Transaction input addresses
     * @type {Array<object>}
     * @memberof ListAddressTransactionsResponseDataInner
     */
    'inputs'?: Array<object>;
    /**
     * Transaction output addresses
     * @type {Array<object>}
     * @memberof ListAddressTransactionsResponseDataInner
     */
    'outputs'?: Array<object>;
}
/**
 * 
 * @export
 * @interface ListAddressTransactionsResponseDataInnerBlock
 */
export interface ListAddressTransactionsResponseDataInnerBlock {
    /**
     * Block number where the transaction was added to the blockchain.
     * @type {number}
     * @memberof ListAddressTransactionsResponseDataInnerBlock
     */
    'block_no'?: number;
    /**
     * Epoch number where the transaction was added to the blockchain.
     * @type {number}
     * @memberof ListAddressTransactionsResponseDataInnerBlock
     */
    'epoch_no'?: number;
    /**
     * Slot number where the transaction was added to the blockchain.
     * @type {any}
     * @memberof ListAddressTransactionsResponseDataInnerBlock
     */
    'epoch_slot_no'?: any;
    /**
     * Timestamp in ISO 8601 format.
     * @type {string}
     * @memberof ListAddressTransactionsResponseDataInnerBlock
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface ListAddressUtxosResponse
 */
export interface ListAddressUtxosResponse {
    /**
     * 
     * @type {Array<ListAddressUtxosResponseDataInner>}
     * @memberof ListAddressUtxosResponse
     */
    'data'?: Array<ListAddressUtxosResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListAddressUtxosResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListAddressUtxosResponseDataInner
 */
export interface ListAddressUtxosResponseDataInner {
    /**
     * Bech32 encoded addresses
     * @type {string}
     * @memberof ListAddressUtxosResponseDataInner
     */
    'address'?: string;
    /**
     * Transaction hash of the UTXO
     * @type {string}
     * @memberof ListAddressUtxosResponseDataInner
     */
    'hash'?: string;
    /**
     * UTXO index in the transaction
     * @type {number}
     * @memberof ListAddressUtxosResponseDataInner
     */
    'index'?: number;
    /**
     * Amount of Ada in the address (in Lovelace)
     * @type {number}
     * @memberof ListAddressUtxosResponseDataInner
     */
    'value'?: number;
    /**
     * True if there is a smart contract
     * @type {boolean}
     * @memberof ListAddressUtxosResponseDataInner
     */
    'smart_contract'?: boolean;
    /**
     * 
     * @type {Array<ListAddressUtxosResponseDataInnerAssetsInner>}
     * @memberof ListAddressUtxosResponseDataInner
     */
    'assets'?: Array<ListAddressUtxosResponseDataInnerAssetsInner>;
}
/**
 * 
 * @export
 * @interface ListAddressUtxosResponseDataInnerAssetsInner
 */
export interface ListAddressUtxosResponseDataInnerAssetsInner {
    /**
     * Asset quantity
     * @type {string}
     * @memberof ListAddressUtxosResponseDataInnerAssetsInner
     */
    'quantity'?: string;
    /**
     * Policy ID controlling an asset
     * @type {string}
     * @memberof ListAddressUtxosResponseDataInnerAssetsInner
     */
    'policy_id'?: string;
    /**
     * Asset name
     * @type {string}
     * @memberof ListAddressUtxosResponseDataInnerAssetsInner
     */
    'asset_name'?: string;
    /**
     * Asset fingerprint (<a href=\"https://cips.cardano.org/cips/cip14/\">CIP14</a>)
     * @type {string}
     * @memberof ListAddressUtxosResponseDataInnerAssetsInner
     */
    'fingerprint'?: string;
}
/**
 * 
 * @export
 * @interface ListAdressListResponse
 */
export interface ListAdressListResponse {
    /**
     * 
     * @type {Array<ListAdressListResponseDataInner>}
     * @memberof ListAdressListResponse
     */
    'data'?: Array<ListAdressListResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListAdressListResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListAdressListResponseDataInner
 */
export interface ListAdressListResponseDataInner {
    /**
     * Address list id.
     * @type {string}
     * @memberof ListAdressListResponseDataInner
     */
    'id'?: string;
    /**
     * Address list name.
     * @type {string}
     * @memberof ListAdressListResponseDataInner
     */
    'name'?: string;
    /**
     * Address list description.
     * @type {string}
     * @memberof ListAdressListResponseDataInner
     */
    'description'?: string;
    /**
     * Size in bytes.
     * @type {number}
     * @memberof ListAdressListResponseDataInner
     */
    'size'?: number;
    /**
     * Number of addressess in the list.
     * @type {number}
     * @memberof ListAdressListResponseDataInner
     */
    'items'?: number;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof ListAdressListResponseDataInner
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof ListAdressListResponseDataInner
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ListAssetAddressesResponse
 */
export interface ListAssetAddressesResponse {
    /**
     * 
     * @type {Array<ListAssetAddressesResponseDataInner>}
     * @memberof ListAssetAddressesResponse
     */
    'data'?: Array<ListAssetAddressesResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListAssetAddressesResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListAssetAddressesResponseDataInner
 */
export interface ListAssetAddressesResponseDataInner {
    /**
     * Bech32 encoded addresses
     * @type {string}
     * @memberof ListAssetAddressesResponseDataInner
     */
    'address'?: string;
    /**
     * Assset quantity
     * @type {string}
     * @memberof ListAssetAddressesResponseDataInner
     */
    'quantity'?: string;
    /**
     * Percentage of asset ownership for a given address compared to the total supply.
     * @type {string}
     * @memberof ListAssetAddressesResponseDataInner
     */
    'share'?: string;
}
/**
 * 
 * @export
 * @interface ListBlockTransactionsResponse
 */
export interface ListBlockTransactionsResponse {
    /**
     * 
     * @type {Array<ListBlockTransactionsResponseDataInner>}
     * @memberof ListBlockTransactionsResponse
     */
    'data'?: Array<ListBlockTransactionsResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListBlockTransactionsResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListBlockTransactionsResponseDataInner
 */
export interface ListBlockTransactionsResponseDataInner {
    /**
     * The hash identifier of the transaction.
     * @type {string}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'hash'?: string;
    /**
     * The index of this transaction with the block (zero based).
     * @type {number}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'block_index'?: number;
    /**
     * The sum of the transaction outputs (in Lovelace).
     * @type {number}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'out_sum'?: number;
    /**
     * The fees paid for this transaction (in Lovelace).
     * @type {number}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'fee'?: number;
    /**
     * Deposit (or deposit refund) in this transaction. Deposits are positive, refunds negative.
     * @type {number}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'deposit'?: number;
    /**
     * The size of the transaction in bytes.
     * @type {number}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'size'?: number;
    /**
     * Transaction in invalid before this slot number.
     * @type {number}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'invalid_before'?: number | null;
    /**
     * Transaction in invalid at or after this slot number.
     * @type {number}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'invalid_hereafter'?: number | null;
    /**
     * False if the contract is invalid. True if the contract is valid or there is no contract.
     * @type {boolean}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'valid_contract'?: boolean;
    /**
     * The sum of the script sizes (in bytes) of scripts in the transaction.
     * @type {number}
     * @memberof ListBlockTransactionsResponseDataInner
     */
    'script_size'?: number;
}
/**
 * 
 * @export
 * @interface ListCollectionsResponse
 */
export interface ListCollectionsResponse {
    /**
     * 
     * @type {Array<NftCollection>}
     * @memberof ListCollectionsResponse
     */
    'data'?: Array<NftCollection>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListCollectionsResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListNftResponse
 */
export interface ListNftResponse {
    /**
     * 
     * @type {Array<NftToken>}
     * @memberof ListNftResponse
     */
    'data'?: Array<NftToken>;
    /**
     * 
     * @type {number}
     * @memberof ListNftResponse
     */
    'status_code'?: number;
}
/**
 * 
 * @export
 * @interface ListNftSalesResponse
 */
export interface ListNftSalesResponse {
    /**
     * 
     * @type {Array<ListNftSalesResponseDataInner>}
     * @memberof ListNftSalesResponse
     */
    'data'?: Array<ListNftSalesResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListNftSalesResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListNftSalesResponseDataInner
 */
export interface ListNftSalesResponseDataInner {
    /**
     * Sale id. This gives you a way to identify a particular sale. Every time you generate a sale you\'ll get a new sale id.
     * @type {string}
     * @memberof ListNftSalesResponseDataInner
     */
    'id'?: string;
    /**
     * NFT status
     * @type {string}
     * @memberof ListNftSalesResponseDataInner
     */
    'status'?: string;
    /**
     * `fixed` for selling a particular token or token list identified by the token-id. `random` for random sales, it will pick random tokens from the collection.
     * @type {string}
     * @memberof ListNftSalesResponseDataInner
     */
    'type'?: string;
    /**
     * Individual token price in Lovelace (1 ADA = 1000000 Lovelace).
     * @type {number}
     * @memberof ListNftSalesResponseDataInner
     */
    'price'?: number;
    /**
     * Amount of ADA received from the sale. This amount goes to the payout wallet defined in the collection.
     * @type {number}
     * @memberof ListNftSalesResponseDataInner
     */
    'income'?: number;
    /**
     * Number of tokens for sale. 1 for NFTs.
     * @type {number}
     * @memberof ListNftSalesResponseDataInner
     */
    'supply'?: number;
    /**
     * Address where the customer has to make the payment.
     * @type {string}
     * @memberof ListNftSalesResponseDataInner
     */
    'payment_address'?: string;
    /**
     * Reservation time in ms. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received, and this timer expires then the NFT is ready for sale again and it can be reserved by another buyer.
     * @type {number}
     * @memberof ListNftSalesResponseDataInner
     */
    'reserved_time'?: number;
    /**
     * Tangocrypto fee per NFT minted.
     * @type {number}
     * @memberof ListNftSalesResponseDataInner
     */
    'service_fee'?: number;
    /**
     * Array of NFTs. The metadata is shown with the same format that is minted.
     * @type {Array<object>}
     * @memberof ListNftSalesResponseDataInner
     */
    'tokens'?: Array<object>;
    /**
     * Transaction ID where the NFT was minted. This field is returned only when the status is `COMPLETED.`
     * @type {string}
     * @memberof ListNftSalesResponseDataInner
     */
    'tx_id'?: string;
    /**
     * transaction fee
     * @type {number}
     * @memberof ListNftSalesResponseDataInner
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof ListNftSalesResponseDataInner
     */
    'nft_fee'?: number;
    /**
     * number of confirmations.
     * @type {number}
     * @memberof ListNftSalesResponseDataInner
     */
    'confirmations'?: number;
    /**
     * Phase id if the NFT is included in a sale phase.
     * @type {string}
     * @memberof ListNftSalesResponseDataInner
     */
    'phase_id'?: string;
    /**
     * Price tier ID.
     * @type {string}
     * @memberof ListNftSalesResponseDataInner
     */
    'price_tier_id'?: string;
    /**
     * 
     * @type {RetrieveNftSaleResponseAffiliate}
     * @memberof ListNftSalesResponseDataInner
     */
    'affiliate'?: RetrieveNftSaleResponseAffiliate;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof ListNftSalesResponseDataInner
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof ListNftSalesResponseDataInner
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ListPolicyAssetsResponse
 */
export interface ListPolicyAssetsResponse {
    /**
     * 
     * @type {Array<ListPolicyAssetsResponseDataInner>}
     * @memberof ListPolicyAssetsResponse
     */
    'data'?: Array<ListPolicyAssetsResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListPolicyAssetsResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListPolicyAssetsResponseDataInner
 */
export interface ListPolicyAssetsResponseDataInner {
    /**
     * Policy ID of the asset
     * @type {string}
     * @memberof ListPolicyAssetsResponseDataInner
     */
    'policy_id'?: string;
    /**
     * Asset name (Hex encoded)
     * @type {string}
     * @memberof ListPolicyAssetsResponseDataInner
     */
    'asset_name'?: string;
    /**
     * Asset fingerprint (<a href=\"https://cips.cardano.org/cips/cip14/\">CIP14</a>)
     * @type {string}
     * @memberof ListPolicyAssetsResponseDataInner
     */
    'fingerprint'?: string;
    /**
     * Asset quantity
     * @type {string}
     * @memberof ListPolicyAssetsResponseDataInner
     */
    'quantity'?: string;
    /**
     * ID of the initial minting transaction
     * @type {string}
     * @memberof ListPolicyAssetsResponseDataInner
     */
    'initial_mint_tx_hash'?: string;
    /**
     * The metadata varies depending on the token type. Usually NFTs use the label 721 and FTs don\'t standard for the label.
     * @type {any}
     * @memberof ListPolicyAssetsResponseDataInner
     */
    'metadata'?: any;
}
/**
 * 
 * @export
 * @interface ListPoolDelegationsResponse
 */
export interface ListPoolDelegationsResponse {
    /**
     * 
     * @type {Array<ListPoolDelegationsResponseDataInner>}
     * @memberof ListPoolDelegationsResponse
     */
    'data'?: Array<ListPoolDelegationsResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListPoolDelegationsResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListPoolDelegationsResponseDataInner
 */
export interface ListPoolDelegationsResponseDataInner {
    /**
     * Bech32 encoded stake addresses.
     * @type {string}
     * @memberof ListPoolDelegationsResponseDataInner
     */
    'stake_address'?: string;
    /**
     * Rewards earned by staking.
     * @type {string}
     * @memberof ListPoolDelegationsResponseDataInner
     */
    'available_rewards'?: string;
    /**
     * Delegated amount (in Lovelace).
     * @type {string}
     * @memberof ListPoolDelegationsResponseDataInner
     */
    'stake'?: string;
}
/**
 * 
 * @export
 * @interface ListSalePhasesResponse
 */
export interface ListSalePhasesResponse {
    /**
     * 
     * @type {Array<ListSalePhasesResponseDataInner>}
     * @memberof ListSalePhasesResponse
     */
    'data'?: Array<ListSalePhasesResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of sale phases. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListSalePhasesResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListSalePhasesResponseDataInner
 */
export interface ListSalePhasesResponseDataInner {
    /**
     * Sales phase ID.
     * @type {string}
     * @memberof ListSalePhasesResponseDataInner
     */
    'id'?: string;
    /**
     * <br /> `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof ListSalePhasesResponseDataInner
     */
    'type'?: string;
    /**
     * True if the sale phase is active, false if is not active.
     * @type {boolean}
     * @memberof ListSalePhasesResponseDataInner
     */
    'active'?: boolean;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {string}
     * @memberof ListSalePhasesResponseDataInner
     */
    'reservation_time'?: string;
    /**
     * Total amount of tokens for sell in the phase.
     * @type {string}
     * @memberof ListSalePhasesResponseDataInner
     */
    'total_tokens'?: string;
    /**
     * Remaining tokens for sale.
     * @type {string}
     * @memberof ListSalePhasesResponseDataInner
     */
    'remaining_tokens'?: string;
    /**
     * A price tier is a way to create bundles and sell them for different prices. For example, you can create a price tier with 10 NFTs for 100 ADA, and the buyer will pay 100 ADA and receive 10 NFTs in their wallet.
     * @type {Array<PriceTierItem>}
     * @memberof ListSalePhasesResponseDataInner
     */
    'price_tiers'?: Array<PriceTierItem>;
    /**
     * Affiliate summary data. This array is shown only if the sale phase has an affiliate program (optional).
     * @type {Array<AffiliateSummary>}
     * @memberof ListSalePhasesResponseDataInner
     */
    'affiliates'?: Array<AffiliateSummary>;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof ListSalePhasesResponseDataInner
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof ListSalePhasesResponseDataInner
     */
    'updated_at'?: string;
}
/**
 * Get transaction UTXOs
 * @export
 * @interface ListTransactionUtxosResponse
 */
export interface ListTransactionUtxosResponse {
    /**
     * Transaction hash
     * @type {string}
     * @memberof ListTransactionUtxosResponse
     */
    'hash'?: string;
    /**
     * 
     * @type {Array<ListTransactionUtxosResponseInputsInner>}
     * @memberof ListTransactionUtxosResponse
     */
    'inputs'?: Array<ListTransactionUtxosResponseInputsInner>;
    /**
     * 
     * @type {Array<ListTransactionUtxosResponseOutputsInner>}
     * @memberof ListTransactionUtxosResponse
     */
    'outputs'?: Array<ListTransactionUtxosResponseOutputsInner>;
}
/**
 * 
 * @export
 * @interface ListTransactionUtxosResponseInputsInner
 */
export interface ListTransactionUtxosResponseInputsInner {
    /**
     * Input address
     * @type {string}
     * @memberof ListTransactionUtxosResponseInputsInner
     */
    'address'?: string;
    /**
     * Transaction hash
     * @type {string}
     * @memberof ListTransactionUtxosResponseInputsInner
     */
    'hash'?: string;
    /**
     * UTXO Index
     * @type {number}
     * @memberof ListTransactionUtxosResponseInputsInner
     */
    'index'?: number;
    /**
     * Ammount of Ada (in Lovelace) in the input
     * @type {number}
     * @memberof ListTransactionUtxosResponseInputsInner
     */
    'value'?: number;
    /**
     * 
     * @type {Array<ListTransactionUtxosResponseInputsInnerAssetsInner>}
     * @memberof ListTransactionUtxosResponseInputsInner
     */
    'assets'?: Array<ListTransactionUtxosResponseInputsInnerAssetsInner>;
}
/**
 * Assets
 * @export
 * @interface ListTransactionUtxosResponseInputsInnerAssetsInner
 */
export interface ListTransactionUtxosResponseInputsInnerAssetsInner {
    /**
     * Asset quantity
     * @type {number}
     * @memberof ListTransactionUtxosResponseInputsInnerAssetsInner
     */
    'quantity'?: number;
    /**
     * Policy ID of the asset
     * @type {string}
     * @memberof ListTransactionUtxosResponseInputsInnerAssetsInner
     */
    'policy_id'?: string;
    /**
     * Asset name
     * @type {string}
     * @memberof ListTransactionUtxosResponseInputsInnerAssetsInner
     */
    'asset_name'?: string;
    /**
     * Asset fingerprint (<a href=\"https://cips.cardano.org/cips/cip14/\">CIP14</a>)
     * @type {string}
     * @memberof ListTransactionUtxosResponseInputsInnerAssetsInner
     */
    'fingerprint'?: string;
}
/**
 * 
 * @export
 * @interface ListTransactionUtxosResponseOutputsInner
 */
export interface ListTransactionUtxosResponseOutputsInner {
    /**
     * Output address
     * @type {string}
     * @memberof ListTransactionUtxosResponseOutputsInner
     */
    'address'?: string;
    /**
     * Transaction hash
     * @type {string}
     * @memberof ListTransactionUtxosResponseOutputsInner
     */
    'hash'?: string;
    /**
     * UTXO Index
     * @type {number}
     * @memberof ListTransactionUtxosResponseOutputsInner
     */
    'index'?: number;
    /**
     * Ammount of Ada (in Lovelace)  in the output
     * @type {number}
     * @memberof ListTransactionUtxosResponseOutputsInner
     */
    'value'?: number;
    /**
     * 
     * @type {Array<ListTransactionUtxosResponseInputsInnerAssetsInner>}
     * @memberof ListTransactionUtxosResponseOutputsInner
     */
    'assets'?: Array<ListTransactionUtxosResponseInputsInnerAssetsInner>;
}
/**
 * 
 * @export
 * @interface ListWalletAddressesResponse
 */
export interface ListWalletAddressesResponse {
    /**
     * 
     * @type {Array<ListWalletAddressesResponseDataInner>}
     * @memberof ListWalletAddressesResponse
     */
    'data'?: Array<ListWalletAddressesResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListWalletAddressesResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListWalletAddressesResponseDataInner
 */
export interface ListWalletAddressesResponseDataInner {
    /**
     * Address associated with the stake key
     * @type {string}
     * @memberof ListWalletAddressesResponseDataInner
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface ListWebhooksResponse
 */
export interface ListWebhooksResponse {
    /**
     * 
     * @type {Array<ListWebhooksResponseDataInner>}
     * @memberof ListWebhooksResponse
     */
    'data'?: Array<ListWebhooksResponseDataInner>;
    /**
     * When the response is truncated, it includes a `cursor` that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof ListWebhooksResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ListWebhooksResponseDataInner
 */
export interface ListWebhooksResponseDataInner {
    /**
     * Webhook name.
     * @type {string}
     * @memberof ListWebhooksResponseDataInner
     */
    'name'?: string;
    /**
     * Webhook network.
     * @type {string}
     * @memberof ListWebhooksResponseDataInner
     */
    'network'?: ListWebhooksResponseDataInnerNetworkEnum;
    /**
     * Webhook description.
     * @type {string}
     * @memberof ListWebhooksResponseDataInner
     */
    'description'?: string;
    /**
     * The url where your server is listening.
     * @type {string}
     * @memberof ListWebhooksResponseDataInner
     */
    'callback_url'?: string;
    /**
     * Every rule is composed of a field, a value and an operator. All the conditions have to be met for the webhook to be triggered. Rules are optional; depending on the number of rules and their parameters, the webhook will be triggered or not. 
     * @type {Array<ListWebhooksResponseDataInnerRulesInner>}
     * @memberof ListWebhooksResponseDataInner
     */
    'rules'?: Array<ListWebhooksResponseDataInnerRulesInner> | null;
    /**
     * Webhook creation date in ISO 8601 format.
     * @type {string}
     * @memberof ListWebhooksResponseDataInner
     */
    'create_date'?: string;
    /**
     * Webhook update date in ISO 8601 format.
     * @type {string}
     * @memberof ListWebhooksResponseDataInner
     */
    'update_date'?: string;
    /**
     * Webhook status.
     * @type {boolean}
     * @memberof ListWebhooksResponseDataInner
     */
    'available'?: boolean;
    /**
     * Number of confirmations of the transaction
     * @type {number}
     * @memberof ListWebhooksResponseDataInner
     */
    'confirmations'?: number;
    /**
     * Webhook id.
     * @type {string}
     * @memberof ListWebhooksResponseDataInner
     */
    'id'?: string;
    /**
     * Wehhook type.
     * @type {string}
     * @memberof ListWebhooksResponseDataInner
     */
    'type'?: ListWebhooksResponseDataInnerTypeEnum;
    /**
     * Payment address.
     * @type {string}
     * @memberof ListWebhooksResponseDataInner
     */
    'address'?: string;
}

export const ListWebhooksResponseDataInnerNetworkEnum = {
    Mainnet: 'mainnet',
    Testnet: 'testnet'
} as const;

export type ListWebhooksResponseDataInnerNetworkEnum = typeof ListWebhooksResponseDataInnerNetworkEnum[keyof typeof ListWebhooksResponseDataInnerNetworkEnum];
export const ListWebhooksResponseDataInnerTypeEnum = {
    Payment: 'payment',
    Block: 'block',
    Transaction: 'transaction',
    Delegation: 'delegation',
    Nft: 'nft'
} as const;

export type ListWebhooksResponseDataInnerTypeEnum = typeof ListWebhooksResponseDataInnerTypeEnum[keyof typeof ListWebhooksResponseDataInnerTypeEnum];

/**
 * 
 * @export
 * @interface ListWebhooksResponseDataInnerRulesInner
 */
export interface ListWebhooksResponseDataInnerRulesInner {
    /**
     * The `field` value depends on the type of webhook. For a full reference vist <a href=\"https://docs.tangocrypto.com/notify/notify/trigger-rules\">Trigger Rules</a>.
     * @type {string}
     * @memberof ListWebhooksResponseDataInnerRulesInner
     */
    'field'?: string;
    /**
     * The `operator` value depends on the type of webhook. For a full reference vist <a href=\"https://docs.tangocrypto.com/notify/notify/trigger-rules\">Trigger Rules</a>.
     * @type {string}
     * @memberof ListWebhooksResponseDataInnerRulesInner
     */
    'operator'?: string;
    /**
     * The `value` value depends on the type of webhook. For a full reference vist <a href=\"https://docs.tangocrypto.com/notify/notify/trigger-rules\">Trigger Rules</a>.
     * @type {string}
     * @memberof ListWebhooksResponseDataInnerRulesInner
     */
    'value'?: string;
}
/**
 * NFT Collection
 * @export
 * @interface NftCollection
 */
export interface NftCollection {
    /**
     * Collection ID.
     * @type {string}
     * @memberof NftCollection
     */
    'id'?: string;
    /**
     * Collection name.
     * @type {string}
     * @memberof NftCollection
     */
    'name'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof NftCollection
     */
    'url'?: string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof NftCollection
     */
    'description'?: string;
    /**
     * 
     * @type {NftCollectionPayoutAddress}
     * @memberof NftCollection
     */
    'payout_address'?: NftCollectionPayoutAddress;
    /**
     * Amount of tokens in the collection.
     * @type {number}
     * @memberof NftCollection
     */
    'token_count'?: number;
    /**
     * Amount of tokens for sale.
     * @type {number}
     * @memberof NftCollection
     */
    'token_for_sale_count'?: number;
    /**
     * Amount of tokens sold.
     * @type {number}
     * @memberof NftCollection
     */
    'token_sold_count'?: number;
    /**
     * The total amount of ADA generated by the sale of NFTs in the collection. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {number}
     * @memberof NftCollection
     */
    'revenue'?: number;
    /**
     * The total amount of ADA generated by the sale of NFTs that goest to the seller.
     * @type {number}
     * @memberof NftCollection
     */
    'income'?: number;
    /**
     * Tangocrypto service fee. This fee depends on your plan and the number of NFTs minted. Check the price page to get more information about it.
     * @type {number}
     * @memberof NftCollection
     */
    'service_fee'?: number;
    /**
     * Total commission paid to affiliates (in Lovelaces). If there are no affiliates, this value is 0.
     * @type {number}
     * @memberof NftCollection
     */
    'affiliate_commission'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof NftCollection
     */
    'nft_fee'?: number;
    /**
     * Transaction fees.
     * @type {number}
     * @memberof NftCollection
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent in fees. This includes transaction fees, nft fees and the service fees.
     * @type {number}
     * @memberof NftCollection
     */
    'total_fees'?: number;
    /**
     * 
     * @type {NftCollectionPolicy}
     * @memberof NftCollection
     */
    'policy'?: NftCollectionPolicy;
    /**
     * 
     * @type {NftCollectionMetadata}
     * @memberof NftCollection
     */
    'metadata'?: NftCollectionMetadata;
    /**
     * 
     * @type {NftCollectionRoyalty}
     * @memberof NftCollection
     */
    'royalty'?: NftCollectionRoyalty;
    /**
     * 
     * @type {NftCollectionRoyaltySaleInfo}
     * @memberof NftCollection
     */
    'royalty_sale_info'?: NftCollectionRoyaltySaleInfo;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof NftCollection
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof NftCollection
     */
    'updated_at'?: string;
}
/**
 * Metadata tags for the collection. The values between `< >` mean that they are tags. A tag is simply a variable that we will evaluate its value when you mint the NFT. You can use the metadata tag to define common attributes shared by all the NFTs in the collection, like the name, copyright, date issued, artist name, social media links, etc. Using metadata tags is not mandatory because you can define all the attributes while creating the individual NFTs. 
 * @export
 * @interface NftCollectionMetadata
 */
export interface NftCollectionMetadata {
    /**
     * Metadata label. In Cardano NFTs are identified by the `721` label.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'label'?: string;
    /**
     * Metadata tag for the NFT name.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'asset_name'?: string;
    /**
     * Metadata tag for the NFT asset name.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'name'?: string;
    /**
     * Metadata tag for the NFT image link.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'image'?: string;
    /**
     * Metadata tag for the media type (also known as a Multipurpose Internet Mail Extensions or MIME type) indicates the nature and format of a document, file, or assortment of bytes. It is common to have NFTs with MIME-type imag, audioand video.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'media_type'?: string;
    /**
     * Metadata tag for the NFT image link.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'description'?: string;
    /**
     * Array of files used for files. This is used when you want to create an NFT with different file formats. For example, you can create several audio files and add them to the metadata.
     * @type {Array<NftCollectionMetadataFilesInner>}
     * @memberof NftCollectionMetadata
     */
    'files'?: Array<NftCollectionMetadataFilesInner>;
    /**
     * Custom attributes or traits for an NFT. You can create 2 types of attributes, fixed or variables. **Fixed**: We include these attributes in the metadata of every NFT minted in the collection with a fixed value. You can add attributes like artist name, Twitter, Discord, copyright etc. You define their value here, and then you don\'t have to submit them during the NFT creation step. **Variables**: Here you set a tag value, and we evaluate variables attributes during the NFT creation step. As you can see in the example, we defined five traits (colour, body, eyes, face, and accessories), but we don\'t specify the value, just a tag between `<>`. 
     * @type {object}
     * @memberof NftCollectionMetadata
     */
    'attributes'?: object;
    /**
     * CIP 25 - NFT Metadata Standard Version
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface NftCollectionMetadataFilesInner
 */
export interface NftCollectionMetadataFilesInner {
    /**
     * Asset name of the file
     * @type {string}
     * @memberof NftCollectionMetadataFilesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftCollectionMetadataFilesInner
     */
    'media_type'?: string;
    /**
     * same as the previous description.
     * @type {string}
     * @memberof NftCollectionMetadataFilesInner
     */
    'src'?: string;
}
/**
 * @type NftCollectionPayoutAddress
 * @export
 */
export type NftCollectionPayoutAddress = Array<NftCollectionPayoutAddressOneOfInner> | string;

/**
 * 
 * @export
 * @interface NftCollectionPayoutAddressOneOfInner
 */
export interface NftCollectionPayoutAddressOneOfInner {
    /**
     * Wallet address that is going to receive a percentage payments of the NFT sale.
     * @type {string}
     * @memberof NftCollectionPayoutAddressOneOfInner
     */
    'addr'?: string;
    /**
     * Wallet name. This is used to identify the wallet.
     * @type {string}
     * @memberof NftCollectionPayoutAddressOneOfInner
     */
    'name'?: string;
    /**
     * Percentage of the sale price earned each time your NFT creation is sold. For example, 0.05 represents 5%.
     * @type {number}
     * @memberof NftCollectionPayoutAddressOneOfInner
     */
    'ratio'?: number;
}
/**
 * 
 * @export
 * @interface NftCollectionPolicy
 */
export interface NftCollectionPolicy {
    /**
     * Defines if the policy will be locked or not. You are not required to chose a date and time to lock the policy, if you set this parameter to false it means that the policy will be open and you can be minting NFTs under this policy forever. If you set this parameter to true then you have to specify a locktime date.
     * @type {boolean}
     * @memberof NftCollectionPolicy
     */
    'lock'?: boolean;
    /**
     * Locktime date in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. It defines how long you\'ll be able to mint NFTs for the collection. The policy will lock after that date, and you won\'t be able to mint more NFTs using the same policy id (even if you use the same key). Hours and minutes are optional; if you set it to `2022-02-24`, it will automatically fill it with 0s, for example, `2022-02-24T00:00:00.000Z`. Take into consideration the desirability and size of your collection before setting this date and leave enough time for selling the NFTs. There is no limited time for the future. 
     * @type {string}
     * @memberof NftCollectionPolicy
     */
    'lock_time'?: string;
    /**
     * Policy ID of the collection. You should post the policy ID in you website, social media or any communication channel you use for buyers to verify the authenticity of the tokens they buy.
     * @type {string}
     * @memberof NftCollectionPolicy
     */
    'policy_id'?: string;
    /**
     * 
     * @type {PolicyScript}
     * @memberof NftCollectionPolicy
     */
    'script'?: PolicyScript;
}
/**
 * 
 * @export
 * @interface NftCollectionRoyalty
 */
export interface NftCollectionRoyalty {
    /**
     * 
     * @type {NftCollectionRoyaltyMetadata}
     * @memberof NftCollectionRoyalty
     */
    'metadata'?: NftCollectionRoyaltyMetadata;
}
/**
 * 
 * @export
 * @interface NftCollectionRoyaltyMetadata
 */
export interface NftCollectionRoyaltyMetadata {
    /**
     * 
     * @type {NftCollectionRoyaltyMetadata777}
     * @memberof NftCollectionRoyaltyMetadata
     */
    '777'?: NftCollectionRoyaltyMetadata777;
}
/**
 * 
 * @export
 * @interface NftCollectionRoyaltyMetadata777
 */
export interface NftCollectionRoyaltyMetadata777 {
    /**
     * Bech32 address split in a two-element array. Each element in the array must have up to 64 bytes.
     * @type {Array<string>}
     * @memberof NftCollectionRoyaltyMetadata777
     */
    'addr'?: Array<string>;
    /**
     * Percentage of the sale price earned each time your NFT creation is sold on a marketplace. For example, 0.05 represents 5%.
     * @type {string}
     * @memberof NftCollectionRoyaltyMetadata777
     */
    'rate'?: string;
}
/**
 * 
 * @export
 * @interface NftCollectionRoyaltySaleInfo
 */
export interface NftCollectionRoyaltySaleInfo {
    /**
     * Sale id where the royalty token was minted.
     * @type {string}
     * @memberof NftCollectionRoyaltySaleInfo
     */
    'sale_id'?: string;
    /**
     * Transaction Id where the royalty token was minted.
     * @type {string}
     * @memberof NftCollectionRoyaltySaleInfo
     */
    'tx_id'?: string;
    /**
     * Amount of Ada spent on fees minting the royalty token.
     * @type {number}
     * @memberof NftCollectionRoyaltySaleInfo
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof NftCollectionRoyaltySaleInfo
     */
    'nft_fee'?: number;
}
/**
 * 
 * @export
 * @interface NftCollectionSummary
 */
export interface NftCollectionSummary {
    /**
     * Collection ID.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'id'?: string;
    /**
     * Collection name.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'name'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'url'?: string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'description'?: string;
    /**
     * Amount of tokens in the collection.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'token_count'?: string;
    /**
     * Amount of tokens for sale.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'token_for_sale_count'?: string;
    /**
     * Amount of tokens sold.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'token_sold_count'?: string;
    /**
     * The total amount of ADA generated by the sale of NFTs in the collection. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'revenue'?: string;
    /**
     * Tangocrypto service fee. This fee depends on your plan and the number of NFTs minted. Check the price page to get more information about it.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'service_fee'?: string;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'nft_fee'?: string;
    /**
     * Transaction fees.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'tx_fee'?: string;
}
/**
 * 
 * @export
 * @interface NftToken
 */
export interface NftToken {
    /**
     * NFT id. This id is within your Tangocrypto account.
     * @type {string}
     * @memberof NftToken
     */
    'id'?: string;
    /**
     * asset name
     * @type {string}
     * @memberof NftToken
     */
    'asset_name'?: string;
    /**
     * name
     * @type {string}
     * @memberof NftToken
     */
    'name'?: string;
    /**
     * The CIP14 fingerprint for the Multi-Asset.
     * @type {string}
     * @memberof NftToken
     */
    'fingerprint'?: string;
    /**
     * There are several states for the tokens `UPLOADING_CONTENT`, `FOR_SALE`, `RESERVED`, `CANCELED`, `COMPLETED`, `EXPIRED`
     * @type {string}
     * @memberof NftToken
     */
    'status'?: string;
    /**
     * Individual token price in Lovelace (1 ADA = 1000000 Lovelace). This field is available when the token is created with the `price`.
     * @type {number}
     * @memberof NftToken
     */
    'price'?: number;
    /**
     * Payment URL. This is the URL you add to your website as a link or a button to buy the NFTs. You can think about this URL as your payment button. This field is available when the token is created with the `price`.
     * @type {string}
     * @memberof NftToken
     */
    'payment_link'?: string;
    /**
     * Token description.
     * @type {string}
     * @memberof NftToken
     */
    'description'?: string;
    /**
     * Link to IPFS image, for example, \"ipfs://QmZHWcx7afrxuvcqeqntZtfv93c2VciBWjyi9LCwUEKZmx\"
     * @type {string}
     * @memberof NftToken
     */
    'image'?: string;
    /**
     * the description
     * @type {string}
     * @memberof NftToken
     */
    'media_type'?: string;
    /**
     * Metadata attributes tag definition. The tag values are matched with the collection tags
     * @type {object}
     * @memberof NftToken
     */
    'metadata_attributes'?: object;
    /**
     * Any arbitrary attributes that you didn\'t include in the collection attributes placeholder definition. Use key-value pairs to define unique attributes for each NFT.
     * @type {object}
     * @memberof NftToken
     */
    'custom_attributes'?: object;
    /**
     * 
     * @type {NftTokenPolicy}
     * @memberof NftToken
     */
    'policy'?: NftTokenPolicy;
    /**
     * NFT Metadata. Here you can see exactly how the metadata will look like once the NFT is minted.
     * @type {object}
     * @memberof NftToken
     */
    'metadata'?: object;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof NftToken
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {number}
     * @memberof NftToken
     */
    'updated_at'?: number;
}
/**
 * 
 * @export
 * @interface NftTokenPolicy
 */
export interface NftTokenPolicy {
    /**
     * Defines if the policy will be locked or not. If you select falsethen you are not required to choose a date and time to lock the policy, therefore the policy will be open and you can be minting NFTs under this policy forever.  If you set this parameter to true then you have to specify a locktime date.
     * @type {boolean}
     * @memberof NftTokenPolicy
     */
    'lock'?: boolean;
    /**
     * Locktime date in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. It defines how long you\'ll be able to mint NFTs for the collection. The policy will lock after that date, and you won\'t be able to mint more NFTs using the same policy id (even if you use the same key). Hours and minutes are optional; if you set it to `2022-02-24`, it will automatically fill it with 0s, for example, `2022-02-24T00:00:00.000Z`. Take into consideration the desirability and size of your collection before setting this date and leave enough time for selling the NFTs. There is no limited time for the future. 
     * @type {string}
     * @memberof NftTokenPolicy
     */
    'lock_time'?: string;
    /**
     * Cardano NFTs need to be identified by the policy id. This id is unique and attached permanently to the asset.
     * @type {string}
     * @memberof NftTokenPolicy
     */
    'policy_id'?: string;
    /**
     * 
     * @type {PolicyScript}
     * @memberof NftTokenPolicy
     */
    'script'?: PolicyScript;
}
/**
 * 
 * @export
 * @interface PolicyScript
 */
export interface PolicyScript {
    /**
     * 
     * @type {string}
     * @memberof PolicyScript
     */
    'type'?: string;
    /**
     * 
     * @type {Array<PolicyScriptScriptsInner>}
     * @memberof PolicyScript
     */
    'scripts'?: Array<PolicyScriptScriptsInner>;
}
/**
 * 
 * @export
 * @interface PolicyScriptScriptsInner
 */
export interface PolicyScriptScriptsInner {
    /**
     * 
     * @type {string}
     * @memberof PolicyScriptScriptsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyScriptScriptsInner
     */
    'keyHash'?: string;
    /**
     * 
     * @type {number}
     * @memberof PolicyScriptScriptsInner
     */
    'slot'?: number;
}
/**
 * 
 * @export
 * @interface PriceTierItem
 */
export interface PriceTierItem {
    /**
     * Price tier ID.
     * @type {string}
     * @memberof PriceTierItem
     */
    'id'?: string;
    /**
     * Price tier name
     * @type {string}
     * @memberof PriceTierItem
     */
    'name'?: string;
    /**
     * Price (in Lovelaces) for the tier. For example, you can create a price tier with amount 5 and price 50. That means the buyer is going to pay 50 ADA for 5 NFTs.
     * @type {number}
     * @memberof PriceTierItem
     */
    'price'?: number;
    /**
     * Amount of tokens to mint in a price tier. For example, you can specify that buyers selecting the bronze price tier will mint 1 token and the buyers choosing the silver price tier will mint 5 tokens.
     * @type {number}
     * @memberof PriceTierItem
     */
    'count'?: number;
    /**
     * Token supply. If you don\'\'t specify the supply, it will be set to 1 by default.
     * @type {number}
     * @memberof PriceTierItem
     */
    'supply'?: number;
    /**
     * Amount of tokens sold with the price tier.
     * @type {number}
     * @memberof PriceTierItem
     */
    'token_sold_count'?: number;
    /**
     * Payment URL. This is the URL you add to your website as a link or a button to buy the NFTs. You can think about this URL as your payment button.
     * @type {string}
     * @memberof PriceTierItem
     */
    'payment_link'?: string;
    /**
     * Affiliate summary data. This array is shown only if the sale phase has an affiliate program (optional).
     * @type {Array<PriceTierItemAffiliatesInner>}
     * @memberof PriceTierItem
     */
    'affiliates'?: Array<PriceTierItemAffiliatesInner>;
}
/**
 * 
 * @export
 * @interface PriceTierItemAffiliatesInner
 */
export interface PriceTierItemAffiliatesInner {
    /**
     * Affiliate id.
     * @type {string}
     * @memberof PriceTierItemAffiliatesInner
     */
    'id'?: string;
    /**
     * Payment link. This is the link that your affiliate has to share with their audience for them to purchase NFTs.
     * @type {string}
     * @memberof PriceTierItemAffiliatesInner
     */
    'payment_link'?: string;
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof PriceTierItemAffiliatesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveAddressListResponse
 */
export interface RetrieveAddressListResponse {
    /**
     * 
     * @type {Array<RetrieveAddressListResponseDataInner>}
     * @memberof RetrieveAddressListResponse
     */
    'data'?: Array<RetrieveAddressListResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof RetrieveAddressListResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveAddressListResponseDataInner
 */
export interface RetrieveAddressListResponseDataInner {
    /**
     * Address list id.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'name'?: string;
    /**
     * Address list name.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'description'?: string;
    /**
     * Size in bytes.
     * @type {number}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'size'?: number;
    /**
     * Number of items.
     * @type {number}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'items'?: number;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<RetrieveAddressListResponseDataInnerAddressesInner>}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'addresses'?: Array<RetrieveAddressListResponseDataInnerAddressesInner>;
}
/**
 * 
 * @export
 * @interface RetrieveAddressListResponseDataInnerAddressesInner
 */
export interface RetrieveAddressListResponseDataInnerAddressesInner {
    /**
     * Cardano address.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInnerAddressesInner
     */
    'address'?: string;
    /**
     * Address notes. Here you can add a brief description of the address or add a date.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInnerAddressesInner
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveAddressSummaryResponse
 */
export interface RetrieveAddressSummaryResponse {
    /**
     * Bech32 encoded addresses
     * @type {string}
     * @memberof RetrieveAddressSummaryResponse
     */
    'address'?: string;
    /**
     * The network that the address belongs to.
     * @type {string}
     * @memberof RetrieveAddressSummaryResponse
     */
    'network'?: RetrieveAddressSummaryResponseNetworkEnum;
    /**
     * Stake address that controls the key
     * @type {string}
     * @memberof RetrieveAddressSummaryResponse
     */
    'stake_address'?: string;
    /**
     * Amount of Ada in the address in Lovelace (1 Ada == 1000000 Lovelace)
     * @type {number}
     * @memberof RetrieveAddressSummaryResponse
     */
    'balance'?: number;
    /**
     * Number of transactions containing the address
     * @type {number}
     * @memberof RetrieveAddressSummaryResponse
     */
    'transactions_count'?: number;
}

export const RetrieveAddressSummaryResponseNetworkEnum = {
    Mainnet: 'mainnet',
    Testnet: 'testnet'
} as const;

export type RetrieveAddressSummaryResponseNetworkEnum = typeof RetrieveAddressSummaryResponseNetworkEnum[keyof typeof RetrieveAddressSummaryResponseNetworkEnum];

/**
 * 
 * @export
 * @interface RetrieveAssetByFingerprintResponse
 */
export interface RetrieveAssetByFingerprintResponse {
    /**
     * Policy ID of the asset
     * @type {string}
     * @memberof RetrieveAssetByFingerprintResponse
     */
    'policy_id'?: string;
    /**
     * Asset name (Hex encoded)
     * @type {string}
     * @memberof RetrieveAssetByFingerprintResponse
     */
    'asset_name'?: string;
    /**
     * Asset fingerprint (<a href=\"https://cips.cardano.org/cips/cip14/\">CIP14</a>)
     * @type {string}
     * @memberof RetrieveAssetByFingerprintResponse
     */
    'fingerprint'?: string;
    /**
     * Asset quantity
     * @type {string}
     * @memberof RetrieveAssetByFingerprintResponse
     */
    'quantity'?: string;
    /**
     * Count of mint and burn transactions
     * @type {string}
     * @memberof RetrieveAssetByFingerprintResponse
     */
    'mint_or_burn_count'?: string;
    /**
     * ID of the initial minting transaction
     * @type {string}
     * @memberof RetrieveAssetByFingerprintResponse
     */
    'initial_mint_tx_hash'?: string;
    /**
     * The metadata varies depending on the token type. Usually NFTs use the label 721 and FTs don\'t standard for the label.
     * @type {object}
     * @memberof RetrieveAssetByFingerprintResponse
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface RetrieveAssetResponse
 */
export interface RetrieveAssetResponse {
    /**
     * Policy ID of the asset
     * @type {string}
     * @memberof RetrieveAssetResponse
     */
    'policy_id'?: string;
    /**
     * Asset name (Hex encoded)
     * @type {string}
     * @memberof RetrieveAssetResponse
     */
    'asset_name'?: string;
    /**
     * Asset fingerprint (<a href=\"https://cips.cardano.org/cips/cip14/\">CIP14</a>)
     * @type {string}
     * @memberof RetrieveAssetResponse
     */
    'fingerprint'?: string;
    /**
     * Asset quantity
     * @type {number}
     * @memberof RetrieveAssetResponse
     */
    'quantity'?: number;
    /**
     * Count of mint and burn transactions
     * @type {number}
     * @memberof RetrieveAssetResponse
     */
    'mint_or_burn_count'?: number;
    /**
     * ID of the initial minting transaction
     * @type {string}
     * @memberof RetrieveAssetResponse
     */
    'initial_mint_tx_hash'?: string;
    /**
     * The metadata varies depending on the token type. Usually NFTs use the label 721 and FTs don\'t standard for the label.  
     * @type {object}
     * @memberof RetrieveAssetResponse
     */
    'metadata'?: object | null;
}
/**
 * 
 * @export
 * @interface RetrieveBlockResponse
 */
export interface RetrieveBlockResponse {
    /**
     * The hash identifier of the block.
     * @type {string}
     * @memberof RetrieveBlockResponse
     */
    'hash'?: string;
    /**
     * The epoch number.
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'epoch_no'?: number;
    /**
     * The slot number.
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'slot_no'?: number;
    /**
     * The slot number within an epoch (resets to zero at the start of each epoch).
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'epoch_slot_no'?: number;
    /**
     * Block number.
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'block_no'?: number;
    /**
     * Number of the previous block.
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'previous_block'?: number;
    /**
     * Number of the next block.
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'next_block'?: number;
    /**
     * Bech32 ID of the slot leader (ie an entity that mines a block).
     * @type {string}
     * @memberof RetrieveBlockResponse
     */
    'slot_leader'?: string;
    /**
     * Total output within the block (in Lovelace).
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'out_sum'?: number;
    /**
     * Total fees within the block (in Lovelace).
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'fees'?: number;
    /**
     * Number of block confirmations.
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'confirmations'?: number;
    /**
     * The block size (in bytes).
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'size'?: number;
    /**
     * Block creation time in ISO 8601 format
     * @type {string}
     * @memberof RetrieveBlockResponse
     */
    'time'?: string;
    /**
     * Number of transactions in the block.
     * @type {number}
     * @memberof RetrieveBlockResponse
     */
    'tx_count'?: number;
    /**
     * The VRF key of the creator of this block.
     * @type {string}
     * @memberof RetrieveBlockResponse
     */
    'vrf_key'?: string;
    /**
     * The hash of the operational certificate of the block producer.
     * @type {string}
     * @memberof RetrieveBlockResponse
     */
    'op_cert'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveCurrentEpochResponse
 */
export interface RetrieveCurrentEpochResponse {
    /**
     * The sum of the transaction output values (in Lovelace) in this epoch.
     * @type {string}
     * @memberof RetrieveCurrentEpochResponse
     */
    'out_sum'?: string;
    /**
     * The sum of the fees (in Lovelace) in this epoch.
     * @type {string}
     * @memberof RetrieveCurrentEpochResponse
     */
    'fees'?: string;
    /**
     * The number of transactions in this epoch.
     * @type {number}
     * @memberof RetrieveCurrentEpochResponse
     */
    'tx_count'?: number;
    /**
     * The number of blocks in this epoch.
     * @type {number}
     * @memberof RetrieveCurrentEpochResponse
     */
    'blk_count'?: number;
    /**
     * The epoch number.
     * @type {number}
     * @memberof RetrieveCurrentEpochResponse
     */
    'no'?: number;
    /**
     * The epoch start time.
     * @type {string}
     * @memberof RetrieveCurrentEpochResponse
     */
    'start_time'?: string;
    /**
     * The epoch end time.
     * @type {string}
     * @memberof RetrieveCurrentEpochResponse
     */
    'end_time'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveEpochParametersResponse
 */
export interface RetrieveEpochParametersResponse {
    /**
     * Epoch number
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'epoch_no'?: number;
    /**
     * The \'a\' parameter to calculate the minimum transaction fee.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'min_fee_a'?: number;
    /**
     * The \'b\' parameter to calculate the minimum transaction fee.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'min_fee_b'?: number;
    /**
     * The maximum block size (in bytes).
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'max_block_size'?: number;
    /**
     * The maximum transaction size (in bytes).
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'max_tx_size'?: number;
    /**
     * The maximum block header size (in bytes).
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'max_block_header_size'?: number;
    /**
     * The amount (in Lovelace) require for a deposit to register a StakeAddress.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'key_deposit'?: number;
    /**
     * The amount (in Lovelace) require for a deposit to register a stake pool.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'pool_deposit'?: number;
    /**
     * The maximum number of epochs in the future that a pool retirement is allowed to be scheduled for.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'max_epoch'?: number;
    /**
     * The optimal number of stake pools (K).
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'optimal_pool_count'?: number;
    /**
     * The influence of the pledge on a stake pool\'s probability on minting a block.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'influence_a0'?: number;
    /**
     * The monetary expansion rate.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'monetary_expand_rate_rho'?: number;
    /**
     * The treasury growth rate.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'treasury_growth_rate_tau'?: number;
    /**
     * The decentralisation parameter (1 fully centralised, 0 fully decentralised).
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'decentralisation'?: number;
    /**
     * The protocol major number.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'protocol_major'?: number;
    /**
     * The protocol minor number.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'protocol_minor'?: number;
    /**
     * The minimum value of a UTxO entry (in Lovelace).
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'min_utxo'?: number;
    /**
     * The minimum pool cost.
     * @type {number}
     * @memberof RetrieveEpochParametersResponse
     */
    'min_pool_cost'?: number;
    /**
     * The nonce value for this epoch.
     * @type {string}
     * @memberof RetrieveEpochParametersResponse
     */
    'nonce'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveNftSaleResponse
 */
export interface RetrieveNftSaleResponse {
    /**
     * Sale id. This gives you a way to identify a particular sale. Every time you generate a sale you\'ll get a new sale id.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'id'?: string;
    /**
     * NFT status
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'status'?: string;
    /**
     * `fixed` for selling a particular token or token list identified by the token-id. `random` for random sales, it will pick random tokens from the collection.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'type'?: string;
    /**
     * Individual token price in Lovelace (1 ADA = 1000000 Lovelace).
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'price'?: number;
    /**
     * Amount of ADA received from the sale. This amount goes to the payout wallet defined in the collection.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'income'?: number;
    /**
     * Number of tokens for sale. 1 for NFTs.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'supply'?: number;
    /**
     * Address where the customer has to make the payment.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'payment_address'?: string;
    /**
     * Reservation time in ms. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received, and this timer expires then the NFT is ready for sale again and it can be reserved by another buyer.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'reserved_time'?: number;
    /**
     * Tangocrypto fee per NFT minted.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'service_fee'?: number;
    /**
     * Array of NFTs. The metadata is shown with the same format that is minted.
     * @type {Array<object>}
     * @memberof RetrieveNftSaleResponse
     */
    'tokens'?: Array<object>;
    /**
     * Transaction ID where the NFT was minted. This field is returned only when the status is `COMPLETED.`
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'tx_id'?: string;
    /**
     * transaction fee
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'nft_fee'?: number;
    /**
     * number of confirmations.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'confirmations'?: number;
    /**
     * Phase id if the NFT is included in a sale phase.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'phase_id'?: string;
    /**
     * 
     * @type {RetrieveNftSaleResponseAffiliate}
     * @memberof RetrieveNftSaleResponse
     */
    'affiliate'?: RetrieveNftSaleResponseAffiliate;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'updated_at'?: string;
}
/**
 * Optional property if the sale was made by an affiliate link.
 * @export
 * @interface RetrieveNftSaleResponseAffiliate
 */
export interface RetrieveNftSaleResponseAffiliate {
    /**
     * Affiliate id
     * @type {string}
     * @memberof RetrieveNftSaleResponseAffiliate
     */
    'id'?: string;
    /**
     * Affiliate name.
     * @type {string}
     * @memberof RetrieveNftSaleResponseAffiliate
     */
    'name'?: string;
    /**
     * Commission rate made by the affiliate (in Lovelaces).
     * @type {number}
     * @memberof RetrieveNftSaleResponseAffiliate
     */
    'commission'?: number;
}
/**
 * 
 * @export
 * @interface RetrievePoolMetadataResponse
 */
export interface RetrievePoolMetadataResponse {
    /**
     * Pool id
     * @type {string}
     * @memberof RetrievePoolMetadataResponse
     */
    'id'?: string;
    /**
     * The Bech32 encoding of the pool hash.
     * @type {string}
     * @memberof RetrievePoolMetadataResponse
     */
    'pool_id'?: string | null;
    /**
     * The amount (in Lovelace) the pool owner pledges to the pool.
     * @type {number}
     * @memberof RetrievePoolMetadataResponse
     */
    'pledge'?: number;
    /**
     * The margin (as a percentage) this pool charges.
     * @type {number}
     * @memberof RetrievePoolMetadataResponse
     */
    'margin'?: number;
    /**
     * The fixed per epoch fee (in ADA) this pool charges.
     * @type {number}
     * @memberof RetrievePoolMetadataResponse
     */
    'fixed_cost'?: number;
    /**
     * The epoch number where this update becomes active.
     * @type {number}
     * @memberof RetrievePoolMetadataResponse
     */
    'active_epoch_no'?: number;
    /**
     * URL to the stake pool metadata
     * @type {string}
     * @memberof RetrievePoolMetadataResponse
     */
    'url'?: string | null;
    /**
     * The expected hash for the off-chain data.
     * @type {string}
     * @memberof RetrievePoolMetadataResponse
     */
    'hash'?: string | null;
    /**
     * The pool\'s ticker name (as many as 5 characters).
     * @type {string}
     * @memberof RetrievePoolMetadataResponse
     */
    'ticker'?: string | null;
    /**
     * Pool name
     * @type {string}
     * @memberof RetrievePoolMetadataResponse
     */
    'name'?: string | null;
    /**
     * Pool description
     * @type {string}
     * @memberof RetrievePoolMetadataResponse
     */
    'description'?: string | null;
    /**
     * Pool URL. This is usually a landing page to explain the pool mission and unique value proposition.
     * @type {string}
     * @memberof RetrievePoolMetadataResponse
     */
    'homepage'?: string | null;
}
/**
 * 
 * @export
 * @interface RetrieveSalePhaseResponse
 */
export interface RetrieveSalePhaseResponse {
    /**
     * Sales phase ID.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'id'?: string;
    /**
     * <br /> `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'type'?: string;
    /**
     * True if the sale phase is active, false if is not active.
     * @type {boolean}
     * @memberof RetrieveSalePhaseResponse
     */
    'active'?: boolean;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'reservation_time'?: string;
    /**
     * Total amount of tokens for sell in the phase.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'total_tokens'?: string;
    /**
     * Remaining tokens for sale.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'remaining_tokens'?: string;
    /**
     * 
     * @type {Array<PriceTierItem>}
     * @memberof RetrieveSalePhaseResponse
     */
    'price_tiers'?: Array<PriceTierItem>;
    /**
     * Affiliate summary data. This array is shown only if the sale phase has an affiliate program (optional).
     * @type {Array<AffiliateSummary>}
     * @memberof RetrieveSalePhaseResponse
     */
    'affiliates'?: Array<AffiliateSummary>;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveTransactionMetadataResponse
 */
export interface RetrieveTransactionMetadataResponse {
    /**
     * 
     * @type {Array<RetrieveTransactionMetadataResponseDataInner>}
     * @memberof RetrieveTransactionMetadataResponse
     */
    'data'?: Array<RetrieveTransactionMetadataResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof RetrieveTransactionMetadataResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveTransactionMetadataResponseDataInner
 */
export interface RetrieveTransactionMetadataResponseDataInner {
    /**
     * Metadata label
     * @type {string}
     * @memberof RetrieveTransactionMetadataResponseDataInner
     */
    'label'?: string;
    /**
     * Content of the metadata
     * @type {object}
     * @memberof RetrieveTransactionMetadataResponseDataInner
     */
    'json'?: object;
}
/**
 * 
 * @export
 * @interface RetrieveTransactionResponse
 */
export interface RetrieveTransactionResponse {
    /**
     * Transaction hash
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'hash'?: string;
    /**
     * Transaction index within the block
     * @type {number}
     * @memberof RetrieveTransactionResponse
     */
    'block_index'?: number;
    /**
     * The sum of all the UTXO per asset
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'out_sum'?: string;
    /**
     * Transaction fee in Lovelace
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'fee'?: string;
    /**
     * Deposit within the transaction in Lovelace
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'deposit'?: string;
    /**
     * Size of the transaction in bytes
     * @type {number}
     * @memberof RetrieveTransactionResponse
     */
    'size'?: number;
    /**
     * Specify a lower bound for a transaction to be valid. The transaction is valid from this slot number (including it) and thereafter.
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'invalid_before'?: string | null;
    /**
     * Specify an upper bound for a transaction to be valid. The transaction is valid up to this slot number (not including it).
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'invalid_hereafter'?: string | null;
    /**
     * Count of UTXOs within the transaction
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'utxo_count'?: string;
    /**
     * Count of the withdrawals within the transaction
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'withdrawal_count'?: string;
    /**
     * Count of the delegations within the transaction
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'delegation_count'?: string;
    /**
     * Count of the stake keys (de)registration and delegation certificates within the transaction
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'stake_cert_count'?: string;
    /**
     * True if the transaction was made to update a pool
     * @type {boolean}
     * @memberof RetrieveTransactionResponse
     */
    'pool_update'?: boolean;
    /**
     * True if the transaction was made to retire a pool
     * @type {boolean}
     * @memberof RetrieveTransactionResponse
     */
    'pool_retire'?: boolean;
    /**
     * Numnber of minted of burned tokens in the transaction
     * @type {string}
     * @memberof RetrieveTransactionResponse
     */
    'asset_mint_or_burn_count'?: string;
    /**
     * 
     * @type {RetrieveTransactionResponseBlock}
     * @memberof RetrieveTransactionResponse
     */
    'block'?: RetrieveTransactionResponseBlock;
    /**
     * 
     * @type {Array<RetrieveTransactionResponseAssetsInner>}
     * @memberof RetrieveTransactionResponse
     */
    'assets'?: Array<RetrieveTransactionResponseAssetsInner>;
}
/**
 * The sum of all the UTXO per asset
 * @export
 * @interface RetrieveTransactionResponseAssetsInner
 */
export interface RetrieveTransactionResponseAssetsInner {
    /**
     * Asset quantity
     * @type {number}
     * @memberof RetrieveTransactionResponseAssetsInner
     */
    'quantity'?: number;
    /**
     * Policy ID of the asset
     * @type {string}
     * @memberof RetrieveTransactionResponseAssetsInner
     */
    'policy_id'?: string;
    /**
     * Asset name
     * @type {string}
     * @memberof RetrieveTransactionResponseAssetsInner
     */
    'asset_name'?: string;
}
/**
 * Block information
 * @export
 * @interface RetrieveTransactionResponseBlock
 */
export interface RetrieveTransactionResponseBlock {
    /**
     * Block hash where the transaction was added to the blockchain.
     * @type {string}
     * @memberof RetrieveTransactionResponseBlock
     */
    'hash'?: string;
    /**
     * Epoch number where the transaction was added to the blockchain.
     * @type {number}
     * @memberof RetrieveTransactionResponseBlock
     */
    'epoch_no'?: number;
    /**
     * Block number where the transaction was added to the blockchain.
     * @type {number}
     * @memberof RetrieveTransactionResponseBlock
     */
    'block_no'?: number;
    /**
     * Slot number where the transaction was added to the blockchain.
     * @type {number}
     * @memberof RetrieveTransactionResponseBlock
     */
    'slot_no'?: number;
}
/**
 * Wallet Object
 * @export
 * @interface RetrieveWalletSummaryResponse
 */
export interface RetrieveWalletSummaryResponse {
    /**
     * Pool ID (in Bech32) where the wallet is delegated to.
     * @type {string}
     * @memberof RetrieveWalletSummaryResponse
     */
    'pool_id'?: string | null;
    /**
     * Registration state of an wallet
     * @type {boolean}
     * @memberof RetrieveWalletSummaryResponse
     */
    'active'?: boolean;
    /**
     * Epoch of the most recent action (registration or deregistration)
     * @type {number}
     * @memberof RetrieveWalletSummaryResponse
     */
    'active_epoch'?: number;
    /**
     * Balance of the wallet (in Lovelace)
     * @type {string}
     * @memberof RetrieveWalletSummaryResponse
     */
    'controlled_total_stake'?: string;
    /**
     * Sum of all rewards for the wallet (in Lovelace)
     * @type {string}
     * @memberof RetrieveWalletSummaryResponse
     */
    'rewards_sum'?: string;
    /**
     * Sum of all withdrawals for the wallet (in Lovelace)
     * @type {string}
     * @memberof RetrieveWalletSummaryResponse
     */
    'withdrawals_sum'?: string;
    /**
     * Sum of all funds from the reserve for the wallet (in Lovelace)
     * @type {string}
     * @memberof RetrieveWalletSummaryResponse
     */
    'reserves_sum'?: string;
    /**
     * Sum of all funds from treasury for the wallet (in Lovelace)
     * @type {string}
     * @memberof RetrieveWalletSummaryResponse
     */
    'treasury_sum'?: string;
    /**
     * Sum of available rewards that haven\'t been withdrawn for the wallet (in Lovelace)
     * @type {string}
     * @memberof RetrieveWalletSummaryResponse
     */
    'withdraw_available'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveWebhookResponse
 */
export interface RetrieveWebhookResponse {
    /**
     * Webhook name
     * @type {string}
     * @memberof RetrieveWebhookResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveWebhookResponse
     */
    'network'?: string;
    /**
     * Webhook description
     * @type {string}
     * @memberof RetrieveWebhookResponse
     */
    'description'?: string;
    /**
     * Destination address.
     * @type {any}
     * @memberof RetrieveWebhookResponse
     */
    'address'?: any;
    /**
     * The URL where your server is listening. We send a POST to this URL with the webhook event.
     * @type {string}
     * @memberof RetrieveWebhookResponse
     */
    'callback_url'?: string;
    /**
     * Every rule is composed of a field, a value and an operator.  
     * @type {Array<RetrieveWebhookResponseRulesInner>}
     * @memberof RetrieveWebhookResponse
     */
    'rules'?: Array<RetrieveWebhookResponseRulesInner>;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveWebhookResponse
     */
    'create_date'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveWebhookResponse
     */
    'update_date'?: string;
    /**
     * True if the webhook is available. False if the webhook is disabled.
     * @type {boolean}
     * @memberof RetrieveWebhookResponse
     */
    'available'?: boolean;
    /**
     * Webhook ID
     * @type {string}
     * @memberof RetrieveWebhookResponse
     */
    'id'?: string;
    /**
     * Webhook type
     * @type {string}
     * @memberof RetrieveWebhookResponse
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveWebhookResponseRulesInner
 */
export interface RetrieveWebhookResponseRulesInner {
    /**
     * Depends on the type of webhook it can be `policy_id`, `asset_name`, `fingerprint`, `ammount`, etc. For a full reference vist <a href=\"https://docs.tangocrypto.com/notify/notify/trigger-rules\">Trigger Rules</a>.
     * @type {string}
     * @memberof RetrieveWebhookResponseRulesInner
     */
    'field'?: string;
    /**
     * Depending on the field it can be `=`, `>`, `<`, `>=`, `<=`\'. For a full reference vist <a href=\"https://docs.tangocrypto.com/notify/notify/trigger-rules\">Trigger Rules</a>.
     * @type {string}
     * @memberof RetrieveWebhookResponseRulesInner
     */
    'operator'?: string;
    /**
     * Depends on the selected field. It can be a numeric value if the field is `amount` or a `policy_id` if the asset is a token. For a full reference vist <a href=\"https://docs.tangocrypto.com/notify/notify/trigger-rules\">Trigger Rules</a>.
     * @type {string}
     * @memberof RetrieveWebhookResponseRulesInner
     */
    'value'?: string;
}
/**
 * submit transaction payload
 * @export
 * @interface SubmitTansactionRequest
 */
export interface SubmitTansactionRequest {
    /**
     * Transaction in CBOR format
     * @type {string}
     * @memberof SubmitTansactionRequest
     */
    'tx': string;
}
/**
 * Submit transaction response
 * @export
 * @interface SubitTansactionResponse
 */
export interface SubitTansactionResponse {
    /**
     * Transaction ID.
     * @type {string}
     * @memberof SubitTansactionResponse
     */
    'tx_id'?: string;
}
/**
 * Create NFT Collection request
 * @export
 * @interface UpdateCollectionRequest
 */
export interface UpdateCollectionRequest {
    /**
     * Collection name. The collection name is internal to your Tangocrypto account. This is just a way to identify different collections.
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'name': string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'url'?: string;
    /**
     * Wallet address that is going to receive the payments of the NFT sale. This should be a wallet address of the seller.
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'payout_address': string;
    /**
     * 
     * @type {CreateCollectionRequestPolicy}
     * @memberof UpdateCollectionRequest
     */
    'policy': CreateCollectionRequestPolicy;
    /**
     * 
     * @type {UpdateCollectionRequestMetadata}
     * @memberof UpdateCollectionRequest
     */
    'metadata'?: UpdateCollectionRequestMetadata;
    /**
     * 
     * @type {NftCollectionRoyalty}
     * @memberof UpdateCollectionRequest
     */
    'royalty'?: NftCollectionRoyalty;
    /**
     * 
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'payment_link'?: string;
}
/**
 * Metadata tags for the collection. The values between `< >` mean that they are tags. A tag is simply a variable that we will assign its value when you mint the NFT. You can use the metadata tag to define common attributes shared by all the NFTs in the collection, like the name, copyright, date issued, artist name, social media links, etc. Using metadata tags is not mandatory because you can define all the attributes while creating the individual NFTs. For more details about Metadata have a look at the CIP (https://cips.cardano.org/cips/cip25/) 
 * @export
 * @interface UpdateCollectionRequestMetadata
 */
export interface UpdateCollectionRequestMetadata {
    /**
     * Metadata tag for the NFT asset name.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'name': string;
    /**
     * Metadata tag for the NFT name.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'asset_name'?: string;
    /**
     * Metadata tag for the NFT description.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'description'?: string;
    /**
     * Metadata tag for the media type (also known as a Multipurpose Internet Mail Extensions or MIME type) indicates the nature and format of a document, file, or assortment of bytes. It is common to have NFTs with MIME-type imag, audioand video.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'media_type'?: string;
    /**
     * Metadata tag for the NFT image link.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'image'?: string;
    /**
     * Array of files used for files. This is used when you want to create an NFT with different file formats. For example, you can create several audio files and add them to the metadata.
     * @type {Array<UpdateCollectionRequestMetadataFilesInner>}
     * @memberof UpdateCollectionRequestMetadata
     */
    'files'?: Array<UpdateCollectionRequestMetadataFilesInner>;
    /**
     * Custom attributes or traits for an NFT. You can create 2 types of attributes, fixed or variables. **Fixed**: We include these attributes in the metadata of every NFT minted in the collection with a fixed value. You can add attributes like artist name, Twitter, Discord, copyright etc. You define their value here, and then you don\'t have to submit them during the NFT creation step. **Variables**: Here you set a tag value, and we evaluate variables attributes during the NFT creation step. As you can see in the example, we defined five traits (colour, body, eyes, face, and accessories), but we don\'t specify the value, just a tag between `<>`. 
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'attributes'?: string;
    /**
     * Metadata version
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCollectionRequestMetadataFilesInner
 */
export interface UpdateCollectionRequestMetadataFilesInner {
    /**
     * Asset name of the file
     * @type {string}
     * @memberof UpdateCollectionRequestMetadataFilesInner
     */
    'name'?: string;
    /**
     * same as the previous description.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadataFilesInner
     */
    'media_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCollectionRequestMetadataFilesInner
     */
    'src'?: string;
}
/**
 * 
 * @export
 * @interface UpdateNftRequest
 */
export interface UpdateNftRequest {
    /**
     * Asset name. Take into consideration is the name is case sensitive and is between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'asset_name'?: string;
    /**
     * Display name. Between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'name'?: string;
    /**
     * Token description. Between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'description'?: string;
    /**
     * (Optional) Individual NFT price in Lovelace (1 ADA = 1000000 Lovelace). This parameter is used for flash minting when you don\'t want to create Sale Phases or Sales and want to make a quick sale.
     * @type {number}
     * @memberof UpdateNftRequest
     */
    'price'?: number;
    /**
     * Media type. For example you can use `image/jpeg`, `image/png`, `image/gif`, `video/mp4`.
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'media_type'?: string;
    /**
     * base64 encoded image.
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'image'?: string;
    /**
     * You have to specify the values for the tag attributes for every token as defined in the collection attribute tag definition when you create the collection. Please take into consideration that we have to define these values for every single NFT in the collection. For example, we set the colour, body, eyes, face and mime type for that particular NFT.For more details about Metadata have a look at the CIP (https://cips.cardano.org/cips/cip25/)
     * @type {Array<CreateNftRequestTokensInnerMetadataAttributesInner>}
     * @memberof UpdateNftRequest
     */
    'metadata_attributes'?: Array<CreateNftRequestTokensInnerMetadataAttributesInner>;
    /**
     * Here you can set any arbitrary attributes that you didn\'t include in the collection attributes tag definition. Use `\"key\":\"value\"` pairs to define unique attributes for each NFT.
     * @type {object}
     * @memberof UpdateNftRequest
     */
    'custom_attributes'?: object;
}
/**
 * 
 * @export
 * @interface UpdateWebhookRequest
 */
export interface UpdateWebhookRequest {
    /**
     * Webhook name
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'name': string;
    /**
     * Webhook description
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'description'?: string;
    /**
     * Webhook type
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'type': UpdateWebhookRequestTypeEnum;
    /**
     * Destination address. This field is used only in the payment webhook and it\'s mandatory in payment webhooks.
     * @type {any}
     * @memberof UpdateWebhookRequest
     */
    'address'?: any;
    /**
     * The URL where your server is listening. We send a POST to this URL with the webhook event.
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'callback_url': string;
    /**
     * Every rule is composed of a field, a value and an operator. All the conditions have to be met for the webhook to be triggered. Rules are optional; depending on the number of rules and their parameters, the webhook will be triggered or not.
     * @type {Array<CreateWebhookRequestRulesInner>}
     * @memberof UpdateWebhookRequest
     */
    'rules'?: Array<CreateWebhookRequestRulesInner>;
}

export const UpdateWebhookRequestTypeEnum = {
    Payment: 'payment',
    Transaction: 'transaction',
    Block: 'block',
    Delegation: 'delegation',
    Nft: 'nft',
    Epoch: 'epoch'
} as const;

export type UpdateWebhookRequestTypeEnum = typeof UpdateWebhookRequestTypeEnum[keyof typeof UpdateWebhookRequestTypeEnum];

/**
 * 
 * @export
 * @interface UpdateWebhookResponse
 */
export interface UpdateWebhookResponse {
    /**
     * Webhook name
     * @type {string}
     * @memberof UpdateWebhookResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookResponse
     */
    'network'?: string;
    /**
     * Webhook description
     * @type {string}
     * @memberof UpdateWebhookResponse
     */
    'description'?: string;
    /**
     * Destination address.
     * @type {any}
     * @memberof UpdateWebhookResponse
     */
    'address'?: any;
    /**
     * The URL where your server is listening. We send a POST to this URL with the webhook event.
     * @type {string}
     * @memberof UpdateWebhookResponse
     */
    'callback_url'?: string;
    /**
     * Every rule is composed of a field, a value and an operator.  
     * @type {Array<RetrieveWebhookResponseRulesInner>}
     * @memberof UpdateWebhookResponse
     */
    'rules'?: Array<RetrieveWebhookResponseRulesInner>;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof UpdateWebhookResponse
     */
    'create_date'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof UpdateWebhookResponse
     */
    'update_date'?: string;
    /**
     * True if the webhook is available. False if the webhook is disabled.
     * @type {boolean}
     * @memberof UpdateWebhookResponse
     */
    'available'?: boolean;
    /**
     * Webhook ID
     * @type {string}
     * @memberof UpdateWebhookResponse
     */
    'id'?: string;
    /**
     * Webhook type
     * @type {string}
     * @memberof UpdateWebhookResponse
     */
    'type'?: string;
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves summarized information of an address.
         * @summary Retrieve address summary
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.            
         * @param {string} address Bech32 address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressSummary: async (appId: string, version: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getAddressSummary', 'appId', appId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAddressSummary', 'address', address)
            const localVarPath = buildPath(appId, version, 'addresses', address);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of assets for a given `address`. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of assets. 
         * @summary List address assets
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} address Bech32 address.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressAssets: async (appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listAddressAssets', 'appId', appId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('listAddressAssets', 'address', address)
            const localVarPath = buildPath(appId, version, 'addresses', address, 'assets');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of UTXOs for a given `address`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
         * @summary List address transactions
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} address Bech32 address.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressTransactions: async (appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listAddressTransactions', 'appId', appId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('listAddressTransactions', 'address', address)
            const localVarPath = buildPath(appId, version, 'addresses', address, 'transactions');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of UTXOs for a given `address`. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of UTXOs. 
         * @summary List address UTXOs
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} address Bech32 address.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressUtxos: async (appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listAddressUtxos', 'appId', appId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('listAddressUtxos', 'address', address)
            const localVarPath = buildPath(appId, version, 'addresses', address, 'utxos');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves summarized information of an address.
         * @summary Retrieve address summary
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} address Bech32 address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressSummary(appId: string, version: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveAddressSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressSummary(appId, version, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of assets for a given `address`. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of assets. 
         * @summary List address assets
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} address Bech32 address.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressAssets(appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListAddressAssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressAssets(appId, version, address, size, cursor, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of UTXOs for a given `address`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
         * @summary List address transactions
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.            
         * @param {string} address Bech32 address.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressTransactions(appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListAddressTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressTransactions(appId, version, address, size, cursor, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of UTXOs for a given `address`. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of UTXOs. 
         * @summary List address UTXOs
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} address Bech32 address.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressUtxos(appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListAddressUtxosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressUtxos(appId, version, address, size, cursor, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Retrieves summarized information of an address.
         * @summary Retrieve address summary
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} address Bech32 address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressSummary(appId: string, version: string, address: string, options?: any): ApiPromise<RetrieveAddressSummaryResponse> {
            return localVarFp.getAddressSummary(appId, version, address, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of assets for a given `address`. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of assets. 
         * @summary List address assets
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} address Bech32 address.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressAssets(appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: any): ApiPromise<ListAddressAssetsResponse> {
            return localVarFp.listAddressAssets(appId, version, address, size, cursor, order, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of UTXOs for a given `address`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
         * @summary List address transactions
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} address Bech32 address.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressTransactions(appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: any): ApiPromise<ListAddressTransactionsResponse> {
            return localVarFp.listAddressTransactions(appId, version, address, size, cursor, order, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of UTXOs for a given `address`. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of UTXOs. 
         * @summary List address UTXOs
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} address Bech32 address.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressUtxos(appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: any): ApiPromise<ListAddressUtxosResponse> {
            return localVarFp.listAddressUtxos(appId, version, address, size, cursor, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * Retrieves summarized information of an address.
     * @summary Retrieve address summary
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} address Bech32 address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getAddressSummary(appId: string, version: string, address: string, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).getAddressSummary(appId, version, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of assets for a given `address`. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of assets. 
     * @summary List address assets
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} address Bech32 address.
     * @param {number} [size] The number of results displayed on one page.
     * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
     * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public listAddressAssets(appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).listAddressAssets(appId, version, address, size, cursor, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of UTXOs for a given `address`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
     * @summary List address transactions
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} address Bech32 address.
     * @param {number} [size] The number of results displayed on one page.
     * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
     * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public listAddressTransactions(appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).listAddressTransactions(appId, version, address, size, cursor, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of UTXOs for a given `address`. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of UTXOs. 
     * @summary List address UTXOs
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} address Bech32 address.
     * @param {number} [size] The number of results displayed on one page.
     * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
     * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public listAddressUtxos(appId: string, version: string, address: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).listAddressUtxos(appId, version, address, size, cursor, order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves information about an asset
         * @summary Retrieve asset
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.              
         * @param {string} asset Concatenation of the policy_id and hex-encoded asset_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (appId: string, version: string, asset: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getAsset', 'appId', appId)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getAsset', 'asset', asset)
            const localVarPath = buildPath(appId, version, 'assets', asset);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Retrieves information about an asset
         * @summary Retrieve asset by fingerprint
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.              
         * @param {string} fingerprint The CIP14 fingerprint for the Multi-Asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByFingerprint: async (appId: string, version: string, fingerprint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getAssetByFingerprint', 'appId', appId)
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('getAssetByFingerprint', 'fingerprint', fingerprint)
            const localVarPath = buildPath(appId, version, 'assets', 'fingerprint', fingerprint);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of addresses and quantities for a given asset. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of addresses. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List asset addresses
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} asset Concatenation of the policy_id and hex-encoded asset_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssetAddresses: async (appId: string, version: string, asset: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listAssetAddresses', 'appId', appId)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('listAssetAddresses', 'asset', asset)
            const localVarPath = buildPath(appId, version, 'assets', asset, 'addresses');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of addresses and quantities holding the given asset. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of owners. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List asset addresses by fingerprint
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.             
         * @param {string} fingerprint The CIP14 fingerprint for the Multi-Asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssetAddressesFingerprint: async (appId: string, version: string, fingerprint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listAssetAddressesFingerprint', 'appId', appId)
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('listAssetAddressesFingerprint', 'fingerprint', fingerprint)
            const localVarPath = buildPath(appId, version, 'assets', 'fingerprint', fingerprint, 'addresses');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves information about an asset
         * @summary Retrieve asset
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} asset Concatenation of the policy_id and hex-encoded asset_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(appId: string, version: string, asset: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveAssetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(appId, version, asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Retrieves information about an asset
         * @summary Retrieve asset by fingerprint
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.             
         * @param {string} fingerprint The CIP14 fingerprint for the Multi-Asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetByFingerprint(appId: string, version: string, fingerprint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveAssetByFingerprintResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetByFingerprint(appId, version, fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of addresses and quantities for a given asset. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of addresses. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List asset addresses
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.             
         * @param {string} asset Concatenation of the policy_id and hex-encoded asset_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAssetAddresses(appId: string, version: string, asset: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListAssetAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAssetAddresses(appId, version, asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of addresses and quantities holding the given asset. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of owners. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List asset addresses by fingerprint
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.             
         * @param {string} fingerprint The CIP14 fingerprint for the Multi-Asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAssetAddressesFingerprint(appId: string, version: string, fingerprint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListAssetAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAssetAddressesFingerprint(appId, version, fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * Retrieves information about an asset
         * @summary Retrieve asset
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} asset Concatenation of the policy_id and hex-encoded asset_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(appId: string, asset: string, options?: any): ApiPromise<RetrieveAssetResponse> {
            return localVarFp.getAsset(appId, asset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves information about an asset
         * @summary Retrieve asset by fingerprint
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} fingerprint The CIP14 fingerprint for the Multi-Asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByFingerprint(appId: string, fingerprint: string, options?: any): ApiPromise<RetrieveAssetByFingerprintResponse> {
            return localVarFp.getAssetByFingerprint(appId, fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of addresses and quantities for a given asset. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of addresses. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List asset addresses
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} asset Concatenation of the policy_id and hex-encoded asset_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssetAddresses(appId: string, asset: string, options?: any): ApiPromise<ListAssetAddressesResponse> {
            return localVarFp.listAssetAddresses(appId, asset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of addresses and quantities holding the given asset. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of owners. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List asset addresses by fingerprint
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} fingerprint The CIP14 fingerprint for the Multi-Asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssetAddressesFingerprint(appId: string, fingerprint: string, options?: any): ApiPromise<ListAssetAddressesResponse> {
            return localVarFp.listAssetAddressesFingerprint(appId, fingerprint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * Retrieves information about an asset
     * @summary Retrieve asset
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} asset Concatenation of the policy_id and hex-encoded asset_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAsset(appId: string, version: string, asset: string, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).getAsset(appId, version, asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information about an asset
     * @summary Retrieve asset by fingerprint
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} fingerprint The CIP14 fingerprint for the Multi-Asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAssetByFingerprint(appId: string, version: string, fingerprint: string, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).getAssetByFingerprint(appId, version, fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of addresses and quantities for a given asset. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of addresses. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
     * @summary List asset addresses
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} asset Concatenation of the policy_id and hex-encoded asset_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public listAssetAddresses(appId: string, version: string, asset: string, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).listAssetAddresses(appId, version, asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of addresses and quantities holding the given asset. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of owners. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
     * @summary List asset addresses by fingerprint
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} fingerprint The CIP14 fingerprint for the Multi-Asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public listAssetAddressesFingerprint(appId: string, version: string, fingerprint: string, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).listAssetAddressesFingerprint(appId, version, fingerprint, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlocksApi - axios parameter creator
 * @export
 */
export const BlocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves information about a block specified by `hash` or `block_no`.
         * @summary Retrieve block
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {number} blockNo Block number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock: async (appId: string, version: string, blockNo: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getBlock', 'appId', appId)
            // verify required parameter 'blockNo' is not null or undefined
            assertParamExists('getBlock', 'blockNo', blockNo)
            const localVarPath = buildPath(appId, version, 'blocks', blockNo.toString());
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Retrieves information about a block specified by `hash` or `block_no`.
         * @summary Retrieve block
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} hash Block hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHash: async (appId: string, version: string, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getBlock', 'appId', appId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getBlock', 'hash', hash)
            const localVarPath = buildPath(appId, version, 'blocks', 'hash', hash);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of transactions for a given block. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
         * @summary List block transactions
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {number} blockNumber Block number.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of the transactions based on block number. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTransactions: async (appId: string, version: string, blockNumber: number, size?: number, cursor?: string, order?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getBlockTransactions', 'appId', appId)
            // verify required parameter 'blockNumber' is not null or undefined
            assertParamExists('getBlockTransactions', 'blockNumber', blockNumber)
            const localVarPath = buildPath(appId, version, 'blocks', blockNumber.toString(), 'transactions');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of transactions for a given block. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
         * @summary List block transactions
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} hash Block hash.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of the transactions based on block number. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTransactionsByHash: async (appId: string, version: string, hash: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getBlockTransactions', 'appId', appId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getBlockTransactions', 'hash', hash)
            const localVarPath = buildPath(appId, version, 'blocks', 'hash', hash, 'transactions');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Retrieves the latest block available. This is known as the tip of the blockchain.
         * @summary Retrieve latest block
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock: async (appId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getLatestBlock', 'appId', appId)
            const localVarPath = buildPath(appId, version, 'blocks', 'latest');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlocksApi - functional programming interface
 * @export
 */
export const BlocksApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BlocksApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves information about a block specified by `hash` or `block_no`.
         * @summary Retrieve block
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {number} blockNo Block number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlock(appId: string, version: string, blockNo: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(appId, version, blockNo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Retrieves information about a block specified by `hash` or `block_no`.
         * @summary Retrieve block
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} hash Block hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHash(appId: string, version: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockByHash(appId, version, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of transactions for a given block. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
         * @summary List block transactions
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {number} blockNumber Block number.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of the transactions based on block number. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockTransactions(appId: string, version: string, blockNumber: number, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListBlockTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockTransactions(appId, version, blockNumber, size, cursor, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of transactions for a given block. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
         * @summary List block transactions
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} hash Block hash.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of the transactions based on block number. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockTransactionsByHash(appId: string, version: string, hash: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListBlockTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockTransactionsByHash(appId, version, hash, size, cursor, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Retrieves the latest block available. This is known as the tip of the blockchain.
         * @summary Retrieve latest block
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestBlock(appId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestBlock(appId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlocksApi - factory interface
 * @export
 */
export const BlocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlocksApiFp(configuration)
    return {
        /**
         * Retrieves information about a block specified by `hash` or `block_no`.
         * @summary Retrieve block
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {number} blockNo Block number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(appId: string, version: string, blockNo: number, options?: any): ApiPromise<RetrieveBlockResponse> {
            return localVarFp.getBlock(appId, version, blockNo, options).then((request) => request(axios, basePath));
        },

        /**
         * Retrieves information about a block specified by `hash` or `block_no`.
         * @summary Retrieve block
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} hash Block hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHash(appId: string, version: string, hash: string, options?: any): ApiPromise<RetrieveBlockResponse> {
            return localVarFp.getBlockByHash(appId, version, hash, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of transactions for a given block. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
         * @summary List block transactions
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {number} blockNumber Block number.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of the transactions based on block number. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTransactions(appId: string, version: string, blockNumber: number, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: any): ApiPromise<ListBlockTransactionsResponse> {
            return localVarFp.getBlockTransactions(appId, version, blockNumber, size, cursor, order, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of transactions for a given block. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
         * @summary List block transactions
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} hash Block hash.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of the transactions based on block number. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockTransactionsByHash(appId: string, version: string, hash: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: any): ApiPromise<ListBlockTransactionsResponse> {
            return localVarFp.getBlockTransactionsByHash(appId, version, hash, size, cursor, order, options).then((request) => request(axios, basePath));
        },

        /**
         * Retrieves the latest block available. This is known as the tip of the blockchain.
         * @summary Retrieve latest block
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock(appId: string, version: string, options?: any): ApiPromise<RetrieveBlockResponse> {
            return localVarFp.getLatestBlock(appId, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlocksApi - object-oriented interface
 * @export
 * @class BlocksApi
 * @extends {BaseAPI}
 */
export class BlocksApi extends BaseAPI {
    /**
     * Retrieves information about a block specified by `hash` or `block_no`.
     * @summary Retrieve block
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {number} blockNo Block number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlock(appId: string, version: string, blockNo: number, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).getBlock(appId, version, blockNo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves information about a block specified by `hash` or `block_no`.
     * @summary Retrieve block
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} hash Block hash.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlockByHash(appId: string, version: string, hash: string, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).getBlockByHash(appId, version, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of transactions for a given block. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
     * @summary List block transactions
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {number} blockNumber Block number.
     * @param {number} [size] The number of results displayed on one page.
     * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
     * @param {'asc' | 'desc'} [order] The ordering of the transactions based on block number. By default, we return oldest first, newest last. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlockTransactions(appId: string, version: string, blockNumber: number, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).getBlockTransactions(appId, version, blockNumber, size, cursor, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of transactions for a given block. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of transactions. 
     * @summary List block transactions
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} hash Block hash.
     * @param {number} [size] The number of results displayed on one page.
     * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
     * @param {'asc' | 'desc'} [order] The ordering of the transactions based on block number. By default, we return oldest first, newest last. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getBlockTransactionsByHash(appId: string, version: string, hash: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).getBlockTransactionsByHash(appId, version, hash, size, cursor, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the latest block available. This is known as the tip of the blockchain.
     * @summary Retrieve latest block
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public getLatestBlock(appId: string, version: string, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).getLatestBlock(appId, version, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EpochsApi - axios parameter creator
 * @export
 */
export const EpochsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the current epoch information
         * @summary Retrieve current epoch information
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCurrentEpoch: async (appId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('retrieveCurrentEpoch', 'appId', appId)
            const localVarPath = buildPath(appId, version, 'epochs', 'current');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Retrieves the protocol parameters for a given epoch.
         * @summary Retrieve protocol parameters
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {number} number Number of the epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEpochParameters: async (appId: string, version: string, number: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('retrieveEpochParameters', 'appId', appId)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('retrieveEpochParameters', 'number', number)
            const localVarPath = buildPath(appId, version, 'epochs', number.toString(), 'parameters');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EpochsApi - functional programming interface
 * @export
 */
export const EpochsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = EpochsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the current epoch information
         * @summary Retrieve current epoch information
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.     
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCurrentEpoch(appId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveCurrentEpochResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCurrentEpoch(appId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Retrieves the protocol parameters for a given epoch.
         * @summary Retrieve protocol parameters
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.     
         * @param {number} number Number of the epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveEpochParameters(appId: string, version: string, number: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveEpochParametersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveEpochParameters(appId, version, number, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EpochsApi - factory interface
 * @export
 */
export const EpochsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EpochsApiFp(configuration)
    return {
        /**
         * Retrieves the current epoch information
         * @summary Retrieve current epoch information
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCurrentEpoch(appId: string, version: string, options?: any): ApiPromise<RetrieveCurrentEpochResponse> {
            return localVarFp.retrieveCurrentEpoch(appId, version, options).then((request) => request(axios, basePath));
        },


        /**
         * Retrieves the protocol parameters for a given epoch.
         * @summary Retrieve protocol parameters
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {number} number Number of the epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEpochParameters(appId: string, version: string, number: number, options?: any): ApiPromise<RetrieveEpochParametersResponse> {
            return localVarFp.retrieveEpochParameters(appId, version, number, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EpochsApi - object-oriented interface
 * @export
 * @class EpochsApi
 * @extends {BaseAPI}
 */
export class EpochsApi extends BaseAPI {
    /**
     * Retrieves the current epoch information
     * @summary Retrieve current epoch information
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EpochsApi
     */
    public retrieveCurrentEpoch(appId: string, version: string, options?: AxiosRequestConfig) {
        return EpochsApiFp(this.configuration).retrieveCurrentEpoch(appId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the protocol parameters for a given epoch.
     * @summary Retrieve protocol parameters
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {number} number Number of the epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EpochsApi
     */
    public retrieveEpochParameters(appId: string, version: string, number: number, options?: AxiosRequestConfig) {
        return EpochsApiFp(this.configuration).retrieveEpochParameters(appId, version, number, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NFTsAddressListApi - axios parameter creator
 * @export
 */
export const NFTsAddressListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns `true` if the address is included in the address list, `false` if not.
         * @summary Check address
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} addressListId Addres list id
         * @param {CheckAddressListRequest} [checkAddressListRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAddressList: async (appId: string, addressListId: string, checkAddressListRequest?: CheckAddressListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('checkAddressList', 'appId', appId)
            // verify required parameter 'addressListId' is not null or undefined
            assertParamExists('checkAddressList', 'addressListId', addressListId)
            const localVarPath = `/{app_id}/v1/nft/address-lists/{address_list_id}/includes`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"address_list_id"}}`, encodeURIComponent(String(addressListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(checkAddressListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new address list in your Tangocrypto account.
         * @summary Create address list
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} name Address list name
         * @param {any} file File in .csv format
         * @param {string} [description] Address list description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddressList: async (appId: string, name: string, file: any, description?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createAddressList', 'appId', appId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createAddressList', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createAddressList', 'file', file)
            const localVarPath = `/{app_id}/v1/nft/address-lists`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


            if (name !== undefined) {
                localVarFormParams.append('name', name as any);
            }

            if (description !== undefined) {
                localVarFormParams.append('description', description as any);
            }

            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an address list in your Tangocrypto account.
         * @summary Delete address list
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} addressListId Address list id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddressList: async (appId: string, addressListId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteAddressList', 'appId', appId)
            // verify required parameter 'addressListId' is not null or undefined
            assertParamExists('deleteAddressList', 'addressListId', addressListId)
            const localVarPath = `/{app_id}/v1/nft/address-lists/{address_list_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"address_list_id"}}`, encodeURIComponent(String(addressListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of address lists. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List Address lists
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressLists: async (appId: string, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getAddressLists', 'appId', appId)
            const localVarPath = `/{app_id}/v1/nft/address-lists`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details for a single NFT.
         * @summary Retrieve an address list
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} addressListId Addres list id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAddressList: async (appId: string, addressListId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('retrieveAddressList', 'appId', appId)
            // verify required parameter 'addressListId' is not null or undefined
            assertParamExists('retrieveAddressList', 'addressListId', addressListId)
            const localVarPath = `/{app_id}/v1/nft/address-lists/{address_list_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"address_list_id"}}`, encodeURIComponent(String(addressListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NFTsAddressListApi - functional programming interface
 * @export
 */
export const NFTsAddressListApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = NFTsAddressListApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns `true` if the address is included in the address list, `false` if not.
         * @summary Check address
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} addressListId Addres list id
         * @param {CheckAddressListRequest} [checkAddressListRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAddressList(appId: string, addressListId: string, checkAddressListRequest?: CheckAddressListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAddressList(appId, addressListId, checkAddressListRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new address list in your Tangocrypto account.
         * @summary Create address list
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} name Address list name
         * @param {any} file File in .csv format
         * @param {string} [description] Address list description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddressList(appId: string, name: string, file: any, description?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreateAddressListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddressList(appId, name, file, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an address list in your Tangocrypto account.
         * @summary Delete address list
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} addressListId Address list id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAddressList(appId: string, addressListId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<DeleteAddressListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddressList(appId, addressListId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of address lists. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List Address lists
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressLists(appId: string, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListAdressListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressLists(appId, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details for a single NFT.
         * @summary Retrieve an address list
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} addressListId Addres list id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAddressList(appId: string, addressListId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveAddressListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAddressList(appId, addressListId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NFTsAddressListApi - factory interface
 * @export
 */
export const NFTsAddressListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NFTsAddressListApiFp(configuration)
    return {
        /**
         * Returns `true` if the address is included in the address list, `false` if not.
         * @summary Check address
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} addressListId Addres list id
         * @param {CheckAddressListRequest} [checkAddressListRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAddressList(appId: string, addressListId: string, checkAddressListRequest?: CheckAddressListRequest, options?: any): ApiPromise<boolean> {
            return localVarFp.checkAddressList(appId, addressListId, checkAddressListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new address list in your Tangocrypto account.
         * @summary Create address list
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} name Address list name
         * @param {any} file File in .csv format
         * @param {string} [description] Address list description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddressList(appId: string, name: string, file: any, description?: string, options?: any): ApiPromise<CreateAddressListResponse> {
            return localVarFp.createAddressList(appId, name, file, description, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an address list in your Tangocrypto account.
         * @summary Delete address list
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} addressListId Address list id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddressList(appId: string, addressListId: string, options?: any): ApiPromise<DeleteAddressListResponse> {
            return localVarFp.deleteAddressList(appId, addressListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of address lists. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List Address lists
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressLists(appId: string, cursor?: string, options?: any): ApiPromise<ListAdressListResponse> {
            return localVarFp.getAddressLists(appId, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details for a single NFT.
         * @summary Retrieve an address list
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} addressListId Addres list id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAddressList(appId: string, addressListId: string, options?: any): ApiPromise<RetrieveAddressListResponse> {
            return localVarFp.retrieveAddressList(appId, addressListId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NFTsAddressListApi - object-oriented interface
 * @export
 * @class NFTsAddressListApi
 * @extends {BaseAPI}
 */
export class NFTsAddressListApi extends BaseAPI {
    /**
     * Returns `true` if the address is included in the address list, `false` if not.
     * @summary Check address
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} addressListId Addres list id
     * @param {CheckAddressListRequest} [checkAddressListRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsAddressListApi
     */
    public checkAddressList(appId: string, addressListId: string, checkAddressListRequest?: CheckAddressListRequest, options?: AxiosRequestConfig) {
        return NFTsAddressListApiFp(this.configuration).checkAddressList(appId, addressListId, checkAddressListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new address list in your Tangocrypto account.
     * @summary Create address list
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} name Address list name
     * @param {any} file File in .csv format
     * @param {string} [description] Address list description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsAddressListApi
     */
    public createAddressList(appId: string, name: string, file: any, description?: string, options?: AxiosRequestConfig) {
        return NFTsAddressListApiFp(this.configuration).createAddressList(appId, name, file, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an address list in your Tangocrypto account.
     * @summary Delete address list
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} addressListId Address list id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsAddressListApi
     */
    public deleteAddressList(appId: string, addressListId: string, options?: AxiosRequestConfig) {
        return NFTsAddressListApiFp(this.configuration).deleteAddressList(appId, addressListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of address lists. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
     * @summary List Address lists
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsAddressListApi
     */
    public getAddressLists(appId: string, cursor?: string, options?: AxiosRequestConfig) {
        return NFTsAddressListApiFp(this.configuration).getAddressLists(appId, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details for a single NFT.
     * @summary Retrieve an address list
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} addressListId Addres list id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsAddressListApi
     */
    public retrieveAddressList(appId: string, addressListId: string, options?: AxiosRequestConfig) {
        return NFTsAddressListApiFp(this.configuration).retrieveAddressList(appId, addressListId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NFTsCollectionsApi - axios parameter creator
 * @export
 */
export const NFTsCollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an NFT Collection in your Tangocrypto account.
         * @summary Delete NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNftCollection: async (appId: string, version: string, collectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteNftCollection', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('deleteNftCollection', 'collectionId', collectionId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of NFTs for a given collection. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List Collection NFTs
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} [status] Filter by token &#x60;status&#x60;. For example, you can get the list of tokens for sale with &#x60;status&#x3D;FOR_SALE&#x60; or tokens sold with &#x60;status&#x3D;COMPLETED&#x60;. For a full reference of the status check https://docs.tangocrypto.com/nfts/nft-api/token-sale-flow
         * @param {string} [order] Use &#x60;asc&#x60; to show the oldest NFT first and &#x60;desc&#x60; to show the most recent NFT first!. If you don\&#39;t specify, this parameter it uses&#x60;desc&#x60; by default.
         * @param {number} [size] The number of NFTs to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionNfts: async (appId: string, version: string, collectionId: string, status?: string, order?: string, size?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getCollectionNfts', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getCollectionNfts', 'collectionId', collectionId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'tokens');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of NFT collections in your Tangocrypto account. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of NFT Collections. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
         * @summary List NFT collections
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {number} [size] The number of collections to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {string} [ids] List of collection ids. **NOTICE:** When you use &#x60;ids&#x60; you can specify a maximum of 25 elements and can\&#39;t use &#x60;cursor&#x60; or &#x60;size&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNftCollections: async (appId: string, version: string, size?: number, cursor?: string, ids?: string[], options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listNftCollections', 'appId', appId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids.join(',');
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Create a new NFT collection in your Tangocrypto account.
         * @summary Create NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftCollection: async (appId: string, version: string, createCollectionRequest?: CreateCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('nftCollection', 'appId', appId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Get details for a single NFT collection in your Tangocrypto account.
         * @summary Retrieve NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId The ID of the NFT Collection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNftCollection: async (appId: string, version: string, collectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('retrieveNftCollection', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('retrieveNftCollection', 'collectionId', collectionId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Updates the NFT collection with the fields that were supplied, leaving the others alone.
         * @summary Update NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.    
         * @param {string} collectionId The ID of the NFT Collection to update.
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNftCollection: async (appId: string, version: string, collectionId: string, updateCollectionRequest?: UpdateCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateNftCollection', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('updateNftCollection', 'collectionId', collectionId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NFTsCollectionsApi - functional programming interface
 * @export
 */
export const NFTsCollectionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = NFTsCollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an NFT Collection in your Tangocrypto account.
         * @summary Delete NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNftCollection(appId: string, version: string, collectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CollectionDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNftCollection(appId, version, collectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of NFTs for a given collection. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List Collection NFTs
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} [status] Filter by token &#x60;status&#x60;. For example, you can get the list of tokens for sale with &#x60;status&#x3D;FOR_SALE&#x60; or tokens sold with &#x60;status&#x3D;COMPLETED&#x60;. For a full reference of the status check https://docs.tangocrypto.com/nfts/nft-api/token-sale-flow
         * @param {string} [order] Use &#x60;asc&#x60; to show the oldest NFT first and &#x60;desc&#x60; to show the most recent NFT first!. If you don\&#39;t specify, this parameter it uses&#x60;desc&#x60; by default.
         * @param {number} [size] The number of NFTs to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionNfts(appId: string, version: string, collectionId: string, status?: string, order?: string, size?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListNftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionNfts(appId, version, collectionId, status, order, size, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of NFT collections in your Tangocrypto account. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of NFT Collections. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
         * @summary List NFT collections
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {number} [size] The number of collections to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {string} [ids] List of collection ids. **NOTICE:** When you use &#x60;ids&#x60; you can specify a maximum of 25 elements and can\&#39;t use &#x60;cursor&#x60; or &#x60;size&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNftCollections(appId: string, version: string, size?: number, cursor?: string, ids?: string[], options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNftCollections(appId, version, size, cursor, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Create a new NFT collection in your Tangocrypto account.
         * @summary Create NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftCollection(appId: string, version: string, createCollectionRequest?: CreateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftCollection(appId, version, createCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Get details for a single NFT collection in your Tangocrypto account.
         * @summary Retrieve NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId The ID of the NFT Collection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveNftCollection(appId: string, version: string, collectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<NftCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveNftCollection(appId, version, collectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Updates the NFT collection with the fields that were supplied, leaving the others alone.
         * @summary Update NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId The ID of the NFT Collection to update.
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNftCollection(appId: string, version: string, collectionId: string, updateCollectionRequest?: UpdateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNftCollection(appId, version, collectionId, updateCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NFTsCollectionsApi - factory interface
 * @export
 */
export const NFTsCollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NFTsCollectionsApiFp(configuration)
    return {
        /**
         * Delete an NFT Collection in your Tangocrypto account.
         * @summary Delete NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNftCollection(appId: string, version: string, collectionId: string, options?: any): ApiPromise<CollectionDeleteResponse> {
            return localVarFp.deleteNftCollection(appId, version, collectionId, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of NFTs for a given collection. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List Collection NFTs
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} [status] Filter by token &#x60;status&#x60;. For example, you can get the list of tokens for sale with &#x60;status&#x3D;FOR_SALE&#x60; or tokens sold with &#x60;status&#x3D;COMPLETED&#x60;. For a full reference of the status check https://docs.tangocrypto.com/nfts/nft-api/token-sale-flow
         * @param {string} [order] Use &#x60;asc&#x60; to show the oldest NFT first and &#x60;desc&#x60; to show the most recent NFT first!. If you don\&#39;t specify, this parameter it uses&#x60;desc&#x60; by default.
         * @param {number} [size] The number of NFTs to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionNfts(appId: string, version: string, collectionId: string, status?: string, order?: string, size?: number, cursor?: string, options?: any): ApiPromise<ListNftResponse> {
            return localVarFp.getCollectionNfts(appId, version, collectionId, status, order, size, cursor, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of NFT collections in your Tangocrypto account. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of NFT Collections. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
         * @summary List NFT collections
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {number} [size] The number of collections to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {string} [ids] List of collection ids. **NOTICE:** When you use &#x60;ids&#x60; you can specify a maximum of 25 elements and can\&#39;t use &#x60;cursor&#x60; or &#x60;size&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNftCollections(appId: string, version: string, size?: number, cursor?: string, ids?: string[], options?: any): ApiPromise<ListCollectionsResponse> {
            return localVarFp.listNftCollections(appId, version, size, cursor, ids, options).then((request) => request(axios, basePath));
        },

        /**
         * Create a new NFT collection in your Tangocrypto account.
         * @summary Create NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftCollection(appId: string, version: string, createCollectionRequest?: CreateCollectionRequest, options?: any): ApiPromise<CreateCollectionResponse> {
            return localVarFp.nftCollection(appId, version, createCollectionRequest, options).then((request) => request(axios, basePath));
        },

        /**
         * Get details for a single NFT collection in your Tangocrypto account.
         * @summary Retrieve NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId The ID of the NFT Collection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNftCollection(appId: string, version: string, collectionId: string, options?: any): ApiPromise<NftCollection> {
            return localVarFp.retrieveNftCollection(appId, version, collectionId, options).then((request) => request(axios, basePath));
        },

        /**
         * Updates the NFT collection with the fields that were supplied, leaving the others alone.
         * @summary Update NFT collection
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId The ID of the NFT Collection to update.
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNftCollection(appId: string, version: string, collectionId: string, updateCollectionRequest?: UpdateCollectionRequest, options?: any): ApiPromise<CreateCollectionResponse> {
            return localVarFp.updateNftCollection(appId, version, collectionId, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NFTsCollectionsApi - object-oriented interface
 * @export
 * @class NFTsCollectionsApi
 * @extends {BaseAPI}
 */
export class NFTsCollectionsApi extends BaseAPI {
    /**
     * Delete an NFT Collection in your Tangocrypto account.
     * @summary Delete NFT collection
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} collectionId Collection ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsCollectionsApi
     */
    public deleteNftCollection(appId: string, version: string, collectionId: string, options?: AxiosRequestConfig) {
        return NFTsCollectionsApiFp(this.configuration).deleteNftCollection(appId, version, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of NFTs for a given collection. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
     * @summary List Collection NFTs
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.      
     * @param {string} collectionId Collection ID
     * @param {string} [status] Filter by token &#x60;status&#x60;. For example, you can get the list of tokens for sale with &#x60;status&#x3D;FOR_SALE&#x60; or tokens sold with &#x60;status&#x3D;COMPLETED&#x60;. For a full reference of the status check https://docs.tangocrypto.com/nfts/nft-api/token-sale-flow
     * @param {string} [order] Use &#x60;asc&#x60; to show the oldest NFT first and &#x60;desc&#x60; to show the most recent NFT first!. If you don\&#39;t specify, this parameter it uses&#x60;desc&#x60; by default.
     * @param {number} [size] The number of NFTs to return in a single page.
     * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsCollectionsApi
     */
    public getCollectionNfts(appId: string, version: string, collectionId: string, status?: string, order?: string, size?: number, cursor?: string, options?: AxiosRequestConfig) {
        return NFTsCollectionsApiFp(this.configuration).getCollectionNfts(appId, version, collectionId, status, order, size, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of NFT collections in your Tangocrypto account. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of NFT Collections. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @summary List NFT collections
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {number} [size] The number of collections to return in a single page.
     * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
     * @param {string} [ids] List of collection ids. **NOTICE:** When you use &#x60;ids&#x60; you can specify a maximum of 25 elements and can\&#39;t use &#x60;cursor&#x60; or &#x60;size&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsCollectionsApi
     */
    public listNftCollections(appId: string, version: string, size?: number, cursor?: string, ids?: string[], options?: AxiosRequestConfig) {
        return NFTsCollectionsApiFp(this.configuration).listNftCollections(appId, version, size, cursor, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new NFT collection in your Tangocrypto account.
     * @summary Create NFT collection
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {CreateCollectionRequest} [createCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsCollectionsApi
     */
    public nftCollection(appId: string, version: string, createCollectionRequest?: CreateCollectionRequest, options?: AxiosRequestConfig) {
        return NFTsCollectionsApiFp(this.configuration).nftCollection(appId, version, createCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details for a single NFT collection in your Tangocrypto account.
     * @summary Retrieve NFT collection
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId The ID of the NFT Collection to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsCollectionsApi
     */
    public retrieveNftCollection(appId: string, version: string, collectionId: string, options?: AxiosRequestConfig) {
        return NFTsCollectionsApiFp(this.configuration).retrieveNftCollection(appId, version, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the NFT collection with the fields that were supplied, leaving the others alone.
     * @summary Update NFT collection
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId The ID of the NFT Collection to update.
     * @param {UpdateCollectionRequest} [updateCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsCollectionsApi
     */
    public updateNftCollection(appId: string, version: string, collectionId: string, updateCollectionRequest?: UpdateCollectionRequest, options?: AxiosRequestConfig) {
        return NFTsCollectionsApiFp(this.configuration).updateNftCollection(appId, version, collectionId, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NFTsSalePhasesApi - axios parameter creator
 * @export
 */
export const NFTsSalePhasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create affiliate.
         * @summary Create affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {CreateAffiliateRequest} [createAffiliateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAffiliate: async (appId: string, version: string, collectionId: string, phaseId: string, createAffiliateRequest?: CreateAffiliateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createAffiliate', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('createAffiliate', 'collectionId', collectionId)
            // verify required parameter 'phaseId' is not null or undefined
            assertParamExists('createAffiliate', 'phaseId', phaseId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases', phaseId, 'affiliates');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createAffiliateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Delete affiliate.
         * @summary Delete Affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sale phase id.
         * @param {string} affiliateId Affiliate id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAffiliate: async (appId: string, version: string, collectionId: string, phaseId: string, affiliateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteAffiliate', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('deleteAffiliate', 'collectionId', collectionId)
            // verify required parameter 'phaseId' is not null or undefined
            assertParamExists('deleteAffiliate', 'phaseId', phaseId)
            // verify required parameter 'affiliateId' is not null or undefined
            assertParamExists('deleteAffiliate', 'affiliateId', affiliateId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases', phaseId, 'affiliates', affiliateId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Update affiliate.
         * @summary Update affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {string} affiliateId Affiliate id.
         * @param {UpdateAffiliateRequest} [updateAffiliateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliate: async (appId: string, version: string, collectionId: string, phaseId: string, affiliateId: string, updateAffiliateRequest?: UpdateAffiliateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateAffiliate', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('updateAffiliate', 'collectionId', collectionId)
            // verify required parameter 'phaseId' is not null or undefined
            assertParamExists('updateAffiliate', 'phaseId', phaseId)
            // verify required parameter 'affiliateId' is not null or undefined
            assertParamExists('updateAffiliate', 'affiliateId', affiliateId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases', phaseId, 'affiliates', affiliateId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateAffiliateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Create price tier.
         * @summary Create price tier
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {CreatePriceTierRequest} [createPriceTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPriceTier: async (appId: string, version: string, collectionId: string, phaseId: string, createPriceTierRequest?: CreatePriceTierRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createPriceTier', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('createPriceTier', 'collectionId', collectionId)
            // verify required parameter 'phaseId' is not null or undefined
            assertParamExists('createPriceTier', 'phaseId', phaseId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases', phaseId, 'price_tiers');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createPriceTierRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Delete price tier.
         * @summary Delete price tier
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sale phase id.
         * @param {string} pricetierId Price Tier id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePriceTier: async (appId: string, version: string, collectionId: string, phaseId: string, pricetierId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deletePriceTier', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('deletePriceTier', 'collectionId', collectionId)
            // verify required parameter 'phaseId' is not null or undefined
            assertParamExists('deletePriceTier', 'phaseId', phaseId)
            // verify required parameter 'pricetierId' is not null or undefined
            assertParamExists('deletePriceTier', 'pricetierId', pricetierId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases', phaseId, 'price_tiers', pricetierId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Update affiliate.
         * @summary Update affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {string} pricetierId Price Tier id.
         * @param {UpdatePriceTierRequest} [updatePriceTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePriceTier: async (appId: string, version: string, collectionId: string, phaseId: string, pricetierId: string, updatePriceTierRequest?: UpdatePriceTierRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updatePriceTier', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('updatePriceTier', 'collectionId', collectionId)
            // verify required parameter 'phaseId' is not null or undefined
            assertParamExists('updatePriceTier', 'phaseId', phaseId)
            // verify required parameter 'pricetierId' is not null or undefined
            assertParamExists('updatePriceTier', 'pricetierId', pricetierId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases', phaseId, 'price_tiers', pricetierId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updatePriceTierRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Delete a sale phase.
         * @summary Delete sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sale phase id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSalePhase: async (appId: string, version: string, collectionId: string, phaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteSalePhase', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('deleteSalePhase', 'collectionId', collectionId)
            // verify required parameter 'phaseId' is not null or undefined
            assertParamExists('deleteSalePhase', 'phaseId', phaseId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases', phaseId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Create a sale phase for a given collection. You can add different phases to control how you will sell the collection. For example, you might have a total of 5000 NFTs, and you want to sell them in stages. You can create a pre-sale phase to sell 1000 NFTs to previous customers at a special price and within a specific time range. You can identify these customers with a condition; that would be an NFT with a certain policy id on their wallets. Then you create another sale phase for the public drop with the remaining 4000 NFTs and no conditions.   
         * @summary Create sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID.
         * @param {CreateSalePhaseRequest} [createSalePhaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftCreateSale: async (appId: string, version: string, collectionId: string, createSalePhaseRequest?: CreateSalePhaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('nftCreateSale', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('nftCreateSale', 'collectionId', collectionId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createSalePhaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns details for a single sale phase.
         * @summary Retrieve sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSalePhase: async (appId: string, version: string, collectionId: string, phaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('retrieveSalePhase', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('retrieveSalePhase', 'collectionId', collectionId)
            // verify required parameter 'phaseId' is not null or undefined
            assertParamExists('retrieveSalePhase', 'phaseId', phaseId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases', phaseId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of sale phases for a given collection. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of sale phases. 
         * @summary List sale phases
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSalePhases: async (appId: string, version: string, collectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('retrieveSalePhases', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('retrieveSalePhases', 'collectionId', collectionId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Update sale phase.
         * @summary Update sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {UpdateSalePhaseRequest} [updateSalePhaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSalePhase: async (appId: string, version: string, collectionId: string, phaseId: string, updateSalePhaseRequest?: UpdateSalePhaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateSalePhase', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('updateSalePhase', 'collectionId', collectionId)
            // verify required parameter 'phaseId' is not null or undefined
            assertParamExists('updateSalePhase', 'phaseId', phaseId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'phases', phaseId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateSalePhaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NFTsSalePhasesApi - functional programming interface
 * @export
 */
export const NFTsSalePhasesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = NFTsSalePhasesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create affiliate.
         * @summary Create affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {CreateAffiliateRequest} [createAffiliateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAffiliate(appId: string, version: string, collectionId: string, phaseId: string, createAffiliateRequest?: CreateAffiliateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreateAffiliateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAffiliate(appId, version, collectionId, phaseId, createAffiliateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Delete affiliate.
         * @summary Delete Affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sale phase id.
         * @param {string} affiliateId Affiliate id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAffiliate(appId: string, version: string, collectionId: string, phaseId: string, affiliateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<DeleteAffiliateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAffiliate(appId, version, collectionId, phaseId, affiliateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Update affiliate.
         * @summary Update affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {string} affiliateId Affiliate id.
         * @param {UpdateAffiliateRequest} [updateAffiliateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAffiliate(appId: string, version: string, collectionId: string, phaseId: string, affiliateId: string, updateAffiliateRequest?: UpdateAffiliateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveSalePhaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAffiliate(appId, version, collectionId, phaseId, affiliateId, updateAffiliateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Create price tier.
         * @summary Create price tier
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {CreateAffiliateRequest} [createPriceTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPriceTier(appId: string, version: string, collectionId: string, phaseId: string, createPriceTierRequest?: CreatePriceTierRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreatePriceTierResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPriceTier(appId, version, collectionId, phaseId, createPriceTierRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Delete price tier.
         * @summary Delete price tier
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sale phase id.
         * @param {string} pricetierId Price Tier id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePriceTier(appId: string, version: string, collectionId: string, phaseId: string, pricetierId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<DeletePriceTierResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePriceTier(appId, version, collectionId, phaseId, pricetierId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Update price tier.
         * @summary Update price tier
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {string} pricetierId Price Tier id.
         * @param {UpdatePriceTierRequest} [updatePriceTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePriceTier(appId: string, version: string, collectionId: string, phaseId: string, pricetierId: string, updatePriceTierRequest?: UpdatePriceTierRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveSalePhaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePriceTier(appId, version, collectionId, phaseId, pricetierId, updatePriceTierRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Delete a sale phase.
         * @summary Delete sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sale phase id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSalePhase(appId: string, version: string, collectionId: string, phaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<DeleteSalePhaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSalePhase(appId, version, collectionId, phaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Create a sale phase for a given collection. You can add different phases to control how you will sell the collection. For example, you might have a total of 5000 NFTs, and you want to sell them in stages. You can create a pre-sale phase to sell 1000 NFTs to previous customers at a special price and within a specific time range. You can identify these customers with a condition; that would be an NFT with a certain policy id on their wallets. Then you create another sale phase for the public drop with the remaining 4000 NFTs and no conditions.   
         * @summary Create sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID.
         * @param {CreateSalePhaseRequest} [createSalePhaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftCreateSale(appId: string, version: string, collectionId: string, createSalePhaseRequest?: CreateSalePhaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreateSalePhaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftCreateSale(appId, version, collectionId, createSalePhaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns details for a single sale phase.
         * @summary Retrieve sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSalePhase(appId: string, version: string, collectionId: string, phaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveSalePhaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSalePhase(appId, version, collectionId, phaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of sale phases for a given collection. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of sale phases. 
         * @summary List sale phases
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSalePhases(appId: string, version: string, collectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListSalePhasesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSalePhases(appId, version, collectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Update sale phase.
         * @summary Update sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {UpdateSalePhaseRequest} [updateSalePhaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSalePhase(appId: string, version: string, collectionId: string, phaseId: string, updateSalePhaseRequest?: UpdateSalePhaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveSalePhaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSalePhase(appId, version, collectionId, phaseId, updateSalePhaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NFTsSalePhasesApi - factory interface
 * @export
 */
export const NFTsSalePhasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NFTsSalePhasesApiFp(configuration)
    return {
        /**
         * Create affiliate.
         * @summary Create affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {CreateAffiliateRequest} [createAffiliateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAffiliate(appId: string, version: string, collectionId: string, phaseId: string, createAffiliateRequest?: CreateAffiliateRequest, options?: any): ApiPromise<CreateAffiliateResponse> {
            return localVarFp.createAffiliate(appId, version, collectionId, phaseId, createAffiliateRequest, options).then((request) => request(axios, basePath));
        },

        /**
         * Delete affiliate.
         * @summary Delete Affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sale phase id.
         * @param {string} affiliateId Affiliate id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAffiliate(appId: string, version: string, collectionId: string, phaseId: string, affiliateId: string, options?: any): ApiPromise<DeleteAffiliateResponse> {
            return localVarFp.deleteAffiliate(appId, version, collectionId, phaseId, affiliateId, options).then((request) => request(axios, basePath));
        },

        /**
         * Delete a sale phase.
         * @summary Delete sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sale phase id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSalePhase(appId: string, version: string, collectionId: string, phaseId: string, options?: any): ApiPromise<DeleteSalePhaseResponse> {
            return localVarFp.deleteSalePhase(appId, version, collectionId, phaseId, options).then((request) => request(axios, basePath));
        },

        /**
         * Create a sale phase for a given collection. You can add different phases to control how you will sell the collection. For example, you might have a total of 5000 NFTs, and you want to sell them in stages. You can create a pre-sale phase to sell 1000 NFTs to previous customers at a special price and within a specific time range. You can identify these customers with a condition; that would be an NFT with a certain policy id on their wallets. Then you create another sale phase for the public drop with the remaining 4000 NFTs and no conditions.   
         * @summary Create sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} collectionId Collection ID.
         * @param {CreateSalePhaseRequest} [createSalePhaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftCreateSale(appId: string, version: string, collectionId: string, createSalePhaseRequest?: CreateSalePhaseRequest, options?: any): ApiPromise<CreateSalePhaseResponse> {
            return localVarFp.nftCreateSale(appId, version, collectionId, createSalePhaseRequest, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns details for a single sale phase.
         * @summary Retrieve sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSalePhase(appId: string, version: string, collectionId: string, phaseId: string, options?: any): ApiPromise<RetrieveSalePhaseResponse> {
            return localVarFp.retrieveSalePhase(appId, version, collectionId, phaseId, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of sale phases for a given collection. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of sale phases. 
         * @summary List sale phases
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} collectionId Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSalePhases(appId: string, version: string, collectionId: string, options?: any): ApiPromise<ListSalePhasesResponse> {
            return localVarFp.retrieveSalePhases(appId, version, collectionId, options).then((request) => request(axios, basePath));
        },

        /**
         * Update affiliate.
         * @summary Update affiliate
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {string} affiliateId Affiliate id.
         * @param {CreateAffiliateRequest} [createAffiliateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliate(appId: string, version: string, collectionId: string, phaseId: string, affiliateId: string, createAffiliateRequest?: CreateAffiliateRequest, options?: any): ApiPromise<RetrieveSalePhaseResponse> {
            return localVarFp.updateAffiliate(appId, version, collectionId, phaseId, affiliateId, createAffiliateRequest, options).then((request) => request(axios, basePath));
        },

        /**
         * Update sale phase.
         * @summary Update sale phase
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} collectionId Collection ID
         * @param {string} phaseId Sales phase ID.
         * @param {CreateSalePhaseRequest} [createSalePhaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSalePhase(appId: string, version: string, collectionId: string, phaseId: string, createSalePhaseRequest?: CreateSalePhaseRequest, options?: any): ApiPromise<RetrieveSalePhaseResponse> {
            return localVarFp.updateSalePhase(appId, version, collectionId, phaseId, createSalePhaseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NFTsSalePhasesApi - object-oriented interface
 * @export
 * @class NFTsSalePhasesApi
 * @extends {BaseAPI}
 */
export class NFTsSalePhasesApi extends BaseAPI {
    /**
     * Create affiliate.
     * @summary Create affiliate
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} collectionId Collection ID
     * @param {string} phaseId Sales phase ID.
     * @param {CreateAffiliateRequest} [createAffiliateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public createAffiliate(appId: string, version: string, collectionId: string, phaseId: string, createAffiliateRequest?: CreateAffiliateRequest, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).createAffiliate(appId, version, collectionId, phaseId, createAffiliateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete affiliate.
     * @summary Delete Affiliate
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {string} phaseId Sale phase id.
     * @param {string} affiliateId Affiliate id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public deleteAffiliate(appId: string, version: string, collectionId: string, phaseId: string, affiliateId: string, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).deleteAffiliate(appId, version, collectionId, phaseId, affiliateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update affiliate.
     * @summary Update affiliate
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.    
     * @param {string} collectionId Collection ID
     * @param {string} phaseId Sales phase ID.
     * @param {string} affiliateId Affiliate id.
     * @param {UpdateAffiliateRequest} [updateAffiliateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public updateAffiliate(appId: string, version: string, collectionId: string, phaseId: string, affiliateId: string, updateAffiliateRequest?: UpdateAffiliateRequest, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).updateAffiliate(appId, version, collectionId, phaseId, affiliateId, updateAffiliateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create price tier.
     * @summary Create price tier
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} collectionId Collection ID
     * @param {string} phaseId Sales phase ID.
     * @param {CreatePriceTierRequest} [createPriceTierRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public createPriceTier(appId: string, version: string, collectionId: string, phaseId: string, createPriceTierRequest?: CreatePriceTierRequest, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).createPriceTier(appId, version, collectionId, phaseId, createPriceTierRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete price tier.
     * @summary Delete price tier
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {string} phaseId Sale phase id.
     * @param {string} pricetierId Price Tier id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public deletePriceTier(appId: string, version: string, collectionId: string, phaseId: string, pricetierId: string, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).deletePriceTier(appId, version, collectionId, phaseId, pricetierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update price tier.
     * @summary Update price tier
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.    
     * @param {string} collectionId Collection ID
     * @param {string} phaseId Sales phase ID.
     * @param {string} pricetierId Price Tier id.
     * @param {UpdatePriceTierRequest} [updatePriceTierRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public updatePriceTier(appId: string, version: string, collectionId: string, phaseId: string, pricetierId: string, updatePriceTierRequest?: UpdatePriceTierRequest, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).updatePriceTier(appId, version, collectionId, phaseId, pricetierId, updatePriceTierRequest, options).then((request) => request(this.axios, this.basePath));
    }



    /**
     * Delete a sale phase.
     * @summary Delete sale phase
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {string} phaseId Sale phase id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public deleteSalePhase(appId: string, version: string, collectionId: string, phaseId: string, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).deleteSalePhase(appId, version, collectionId, phaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a sale phase for a given collection. You can add different phases to control how you will sell the collection. For example, you might have a total of 5000 NFTs, and you want to sell them in stages. You can create a pre-sale phase to sell 1000 NFTs to previous customers at a special price and within a specific time range. You can identify these customers with a condition; that would be an NFT with a certain policy id on their wallets. Then you create another sale phase for the public drop with the remaining 4000 NFTs and no conditions.   
     * @summary Create sale phase
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID.
     * @param {CreateSalePhaseRequest} [createSalePhaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public nftCreateSale(appId: string, version: string, collectionId: string, createSalePhaseRequest?: CreateSalePhaseRequest, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).nftCreateSale(appId, version, collectionId, createSalePhaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details for a single sale phase.
     * @summary Retrieve sale phase
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {string} phaseId Sales phase ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public retrieveSalePhase(appId: string, version: string, collectionId: string, phaseId: string, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).retrieveSalePhase(appId, version, collectionId, phaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of sale phases for a given collection. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of sale phases. 
     * @summary List sale phases
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public retrieveSalePhases(appId: string, version: string, collectionId: string, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).retrieveSalePhases(appId, version, collectionId, options).then((request) => request(this.axios, this.basePath));
    }


    /**
     * Update sale phase.
     * @summary Update sale phase
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {string} phaseId Sales phase ID.
     * @param {UpdateSalePhaseRequest} [updateSalePhaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalePhasesApi
     */
    public updateSalePhase(appId: string, version: string, collectionId: string, phaseId: string, updateSalePhaseRequest?: UpdateSalePhaseRequest, options?: AxiosRequestConfig) {
        return NFTsSalePhasesApiFp(this.configuration).updateSalePhase(appId, version, collectionId, phaseId, updateSalePhaseRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NFTsSalesApi - axios parameter creator
 * @export
 */
export const NFTsSalesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a sale for a given NFT. When you cancel a sale the status of the NFT will return back to `OPEN`
         * @summary Cancel NFT sale
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID
         * @param {string} tokenId Token ID
         * @param {string} saleId Sale ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelNftSale: async (appId: string, version: string, collectionId: string, tokenId: string, saleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('cancelNftSale', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('cancelNftSale', 'collectionId', collectionId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('cancelNftSale', 'tokenId', tokenId)
            // verify required parameter 'saleId' is not null or undefined
            assertParamExists('cancelNftSale', 'saleId', saleId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'sales', saleId, 'cancel');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Create an NFT sale. You can sell multiple tokens in a single sale.
         * @summary Create NFT sale
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {CreateNftSaleRequest} [createNftSaleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNftSale: async (appId: string, version: string, collectionId: string, createNftSaleRequest?: CreateNftSaleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createNftSale', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('createNftSale', 'collectionId', collectionId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'sales');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createNftSaleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of Sales for a given collection. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List NFT sales
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} [order] Use &#x60;asc&#x60; to show the oldest NFT first and &#x60;desc&#x60; to show the most recent NFT first!. If you don\&#39;t specify, this parameter it uses&#x60;desc&#x60; by default.
         * @param {number} [size] The number of NFTs to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNftSales: async (appId: string, version: string, collectionId: string, order?: string, size?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listNftSales', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('listNftSales', 'collectionId', collectionId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'sales');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns details for a single NFT sale. With this endpoint, you can check the remaining reservation time or if the sale is expired. Also, you can check if a customer has made a partial payment or if the total amount was paid. Once the payment is received, the NFT is minted and sent to the buyer\'s wallet address.
         * @summary Retrieve NFT Sale
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} saleId Sale ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNFTSale: async (appId: string, version: string, collectionId: string, saleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('retrieveNFTSale', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('retrieveNFTSale', 'collectionId', collectionId)
            // verify required parameter 'saleId' is not null or undefined
            assertParamExists('retrieveNFTSale', 'saleId', saleId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'sales', saleId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NFTsSalesApi - functional programming interface
 * @export
 */
export const NFTsSalesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = NFTsSalesApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a sale for a given NFT. When you cancel a sale the status of the NFT will return back to `OPEN`
         * @summary Cancel NFT sale
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID
         * @param {string} tokenId Token ID
         * @param {string} saleId Sale ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelNftSale(appId: string, version: string, collectionId: string, tokenId: string, saleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CancelNftSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelNftSale(appId, version, collectionId, tokenId, saleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Create an NFT sale. You can sell multiple tokens in a single sale.
         * @summary Create NFT sale
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {CreateNftSaleRequest} [createNftSaleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNftSale(appId: string, version: string, collectionId: string, createNftSaleRequest?: CreateNftSaleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreateNftSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNftSale(appId, version, collectionId, createNftSaleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of Sales for a given collection. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List NFT sales
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} [order] Use &#x60;asc&#x60; to show the oldest NFT first and &#x60;desc&#x60; to show the most recent NFT first!. If you don\&#39;t specify, this parameter it uses&#x60;desc&#x60; by default.
         * @param {number} [size] The number of NFTs to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNftSales(appId: string, version: string, collectionId: string, order?: string, size?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListNftSalesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNftSales(appId, version, collectionId, order, size, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns details for a single NFT sale. With this endpoint, you can check the remaining reservation time or if the sale is expired. Also, you can check if a customer has made a partial payment or if the total amount was paid. Once the payment is received, the NFT is minted and sent to the buyer\'s wallet address.
         * @summary Retrieve NFT Sale
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} salesId Sales ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveNFTSale(appId: string, version: string, collectionId: string, salesId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveNftSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveNFTSale(appId, version, collectionId, salesId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NFTsSalesApi - factory interface
 * @export
 */
export const NFTsSalesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NFTsSalesApiFp(configuration)
    return {
        /**
         * Cancel a sale for a given NFT. When you cancel a sale the status of the NFT will return back to `OPEN`
         * @summary Cancel NFT sale
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID
         * @param {string} tokenId Token ID
         * @param {string} saleId Sale ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelNftSale(appId: string, version: string, collectionId: string, tokenId: string, saleId: string, options?: any): ApiPromise<CancelNftSaleResponse> {
            return localVarFp.cancelNftSale(appId, version, collectionId, tokenId, saleId, options).then((request) => request(axios, basePath));
        },

        /**
         * Create an NFT sale. You can sell multiple tokens in a single sale.
         * @summary Create NFT sale
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {CreateNftSaleRequest} [createNftSaleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNftSale(appId: string, version: string, collectionId: string, createNftSaleRequest?: CreateNftSaleRequest, options?: any): ApiPromise<CreateNftSaleResponse> {
            return localVarFp.createNftSale(appId, version, collectionId, createNftSaleRequest, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of Sales for a given collection. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List NFT sales
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} [order] Use &#x60;asc&#x60; to show the oldest NFT first and &#x60;desc&#x60; to show the most recent NFT first!. If you don\&#39;t specify, this parameter it uses&#x60;desc&#x60; by default.
         * @param {number} [size] The number of NFTs to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNftSales(appId: string, version: string, collectionId: string, order?: string, size?: number, cursor?: string, options?: any): ApiPromise<ListNftSalesResponse> {
            return localVarFp.listNftSales(appId, version, collectionId, order, size, cursor, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns details for a single NFT sale. With this endpoint, you can check the remaining reservation time or if the sale is expired. Also, you can check if a customer has made a partial payment or if the total amount was paid. Once the payment is received, the NFT is minted and sent to the buyer\'s wallet address.
         * @summary Retrieve NFT Sale
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} salesId Sales ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNFTSale(appId: string, version: string, collectionId: string, salesId: string, options?: any): ApiPromise<RetrieveNftSaleResponse> {
            return localVarFp.retrieveNFTSale(appId, version, collectionId, salesId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NFTsSalesApi - object-oriented interface
 * @export
 * @class NFTsSalesApi
 * @extends {BaseAPI}
 */
export class NFTsSalesApi extends BaseAPI {
    /**
     * Cancel a sale for a given NFT. When you cancel a sale the status of the NFT will return back to `OPEN`
     * @summary Cancel NFT sale
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} collectionId Collection ID
     * @param {string} tokenId Token ID
     * @param {string} saleId Sale ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalesApi
     */
    public cancelNftSale(appId: string, version: string, collectionId: string, tokenId: string, saleId: string, options?: AxiosRequestConfig) {
        return NFTsSalesApiFp(this.configuration).cancelNftSale(appId, version, collectionId, tokenId, saleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an NFT sale. You can sell multiple tokens in a single sale.
     * @summary Create NFT sale
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {CreateNftSaleRequest} [createNftSaleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalesApi
     */
    public createNftSale(appId: string, version: string, collectionId: string, createNftSaleRequest?: CreateNftSaleRequest, options?: AxiosRequestConfig) {
        return NFTsSalesApiFp(this.configuration).createNftSale(appId, version, collectionId, createNftSaleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Sales for a given collection. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of NFTs. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
     * @summary List NFT sales
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {string} [order] Use &#x60;asc&#x60; to show the oldest NFT first and &#x60;desc&#x60; to show the most recent NFT first!. If you don\&#39;t specify, this parameter it uses&#x60;desc&#x60; by default.
     * @param {number} [size] The number of NFTs to return in a single page.
     * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalesApi
     */
    public listNftSales(appId: string, version: string, collectionId: string, order?: string, size?: number, cursor?: string, options?: AxiosRequestConfig) {
        return NFTsSalesApiFp(this.configuration).listNftSales(appId, version, collectionId, order, size, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details for a single NFT sale. With this endpoint, you can check the remaining reservation time or if the sale is expired. Also, you can check if a customer has made a partial payment or if the total amount was paid. Once the payment is received, the NFT is minted and sent to the buyer\'s wallet address.
     * @summary Retrieve NFT Sale
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {string} salesId Sales ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsSalesApi
     */
    public retrieveNFTSale(appId: string, version: string, collectionId: string, salesId: string, options?: AxiosRequestConfig) {
        return NFTsSalesApiFp(this.configuration).retrieveNFTSale(appId, version, collectionId, salesId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NFTsTokensApi - axios parameter creator
 * @export
 */
export const NFTsTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an NFT in your Tangocrypto account.
         * @summary Delete NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID
         * @param {string} tokenId NFT id within your Tangocrypto account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNft: async (appId: string, version: string, collectionId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteNft', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('deleteNft', 'collectionId', collectionId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('deleteNft', 'tokenId', tokenId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'tokens', tokenId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Create NFT in a Collection 
         * @summary Create NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID.
         * @param {CreateNftRequest} [createNftRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftCreateNft: async (appId: string, version: string, collectionId: string, createNftRequest?: CreateNftRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('nftCreateNft', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('nftCreateNft', 'collectionId', collectionId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'tokens');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createNftRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns details for a single NFT.
         * @summary Retrieve NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} tokenId NFT id within your Tangocrypto account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNFT: async (appId: string, version: string, collectionId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('retrieveNFT', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('retrieveNFT', 'collectionId', collectionId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('retrieveNFT', 'tokenId', tokenId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'tokens', tokenId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Updates the NFT with the supplied parameters. The ones not provided  remain with the same value.
         * @summary Update NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} tokenId NFT id within your Tangocrypto account.
         * @param {UpdateNftRequest} [updateNftRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNFT: async (appId: string, version: string, collectionId: string, tokenId: string, updateNftRequest?: UpdateNftRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateNFT', 'appId', appId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('updateNFT', 'collectionId', collectionId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('updateNFT', 'tokenId', tokenId)
            const localVarPath = buildPath(appId, version, 'nft', 'collections', collectionId, 'tokens', tokenId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateNftRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NFTsTokensApi - functional programming interface
 * @export
 */
export const NFTsTokensApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = NFTsTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an NFT in your Tangocrypto account.
         * @summary Delete NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} collectionId Collection ID
         * @param {string} tokenId NFT id within your Tangocrypto account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNft(appId: string, version: string, collectionId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<DeleteNftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNft(appId, version, collectionId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Create NFT in a Collection 
         * @summary Create NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID.
         * @param {CreateNftRequest} [createNftRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftCreateNft(appId: string, version: string, collectionId: string, createNftRequest?: CreateNftRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreateNftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftCreateNft(appId, version, collectionId, createNftRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns details for a single NFT.
         * @summary Retrieve NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} tokenId NFT id within your Tangocrypto account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveNFT(appId: string, version: string, collectionId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<NftToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveNFT(appId, version, collectionId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Updates the NFT with the supplied parameters. The ones not provided  remain with the same value.
         * @summary Update NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} tokenId NFT id within your Tangocrypto account.
         * @param {UpdateNftRequest} [updateNftRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNFT(appId: string, version: string, collectionId: string, tokenId: string, updateNftRequest?: UpdateNftRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreateNftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNFT(appId, version, collectionId, tokenId, updateNftRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NFTsTokensApi - factory interface
 * @export
 */
export const NFTsTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NFTsTokensApiFp(configuration)
    return {
        /**
         * Delete an NFT in your Tangocrypto account.
         * @summary Delete NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} tokenId NFT id within your Tangocrypto account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNft(appId: string, version: string, collectionId: string, tokenId: string, options?: any): ApiPromise<DeleteNftResponse> {
            return localVarFp.deleteNft(appId, version, collectionId, tokenId, options).then((request) => request(axios, basePath));
        },

        /**
         * Create NFT in a Collection 
         * @summary Create NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID.
         * @param {CreateNftRequest} [createNftRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftCreateNft(appId: string, version: string, collectionId: string, createNftRequest?: CreateNftRequest, options?: any): ApiPromise<CreateNftResponse> {
            return localVarFp.nftCreateNft(appId, version, collectionId, createNftRequest, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns details for a single NFT.
         * @summary Retrieve NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} tokenId NFT id within your Tangocrypto account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNFT(appId: string, version: string, collectionId: string, tokenId: string, options?: any): ApiPromise<NftToken> {
            return localVarFp.retrieveNFT(appId, version, collectionId, tokenId, options).then((request) => request(axios, basePath));
        },

        /**
         * Updates the NFT with the supplied parameters. The ones not provided  remain with the same value.
         * @summary Update NFT
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} collectionId Collection ID
         * @param {string} tokenId NFT id within your Tangocrypto account.
         * @param {UpdateNftRequest} [updateNftRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNFT(appId: string, version: string, collectionId: string, tokenId: string, updateNftRequest?: UpdateNftRequest, options?: any): ApiPromise<CreateNftResponse> {
            return localVarFp.updateNFT(appId, version, collectionId, tokenId, updateNftRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NFTsTokensApi - object-oriented interface
 * @export
 * @class NFTsTokensApi
 * @extends {BaseAPI}
 */
export class NFTsTokensApi extends BaseAPI {
    /**
     * Delete an NFT in your Tangocrypto account.
     * @summary Delete NFT
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} collectionId Collection ID
     * @param {string} tokenId NFT id within your Tangocrypto account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsTokensApi
     */
    public deleteNft(appId: string, version: string, collectionId: string, tokenId: string, options?: AxiosRequestConfig) {
        return NFTsTokensApiFp(this.configuration).deleteNft(appId, version, collectionId, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create NFT in a Collection 
     * @summary Create NFT
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID.
     * @param {CreateNftRequest} [createNftRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsTokensApi
     */
    public nftCreateNft(appId: string, version: string, collectionId: string, createNftRequest?: CreateNftRequest, options?: AxiosRequestConfig) {
        return NFTsTokensApiFp(this.configuration).nftCreateNft(appId, version, collectionId, createNftRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details for a single NFT.
     * @summary Retrieve NFT
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {string} tokenId NFT id within your Tangocrypto account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsTokensApi
     */
    public retrieveNFT(appId: string, version: string, collectionId: string, tokenId: string, options?: AxiosRequestConfig) {
        return NFTsTokensApiFp(this.configuration).retrieveNFT(appId, version, collectionId, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the NFT with the supplied parameters. The ones not provided  remain with the same value.
     * @summary Update NFT
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} collectionId Collection ID
     * @param {string} tokenId NFT id within your Tangocrypto account.
     * @param {UpdateNftRequest} [updateNftRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsTokensApi
     */
    public updateNFT(appId: string, version: string, collectionId: string, tokenId: string, updateNftRequest?: UpdateNftRequest, options?: AxiosRequestConfig) {
        return NFTsTokensApiFp(this.configuration).updateNFT(appId, version, collectionId, tokenId, updateNftRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PolicyApi - axios parameter creator
 * @export
 */
export const PolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of assets with the given Policy ID. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of owners. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List assets by policy
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} policyId Policy ID controlling an asset.
         * @param {number} [size] The number of assets to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByPolicy: async (appId: string, version: string, policyId: string, size?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getAssetByPolicy', 'appId', appId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('getAssetByPolicy', 'policyId', policyId)
            const localVarPath = buildPath(appId, version, 'policies', policyId, 'assets');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyApi - functional programming interface
 * @export
 */
export const PolicyApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of assets with the given Policy ID. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of owners. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List assets by policy
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} policyId Policy ID controlling an asset.
         * @param {number} [size] The number of assets to return in a single page.
         * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetByPolicy(appId: string, version: string, policyId: string, size?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListPolicyAssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetByPolicy(appId, version, policyId, size, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PolicyApi - factory interface
 * @export
 */
export const PolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicyApiFp(configuration)
    return {
        /**
         * Returns a list of assets with the given Policy ID. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of owners. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
         * @summary List assets by policy
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} policyId Policy ID controlling an asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByPolicy(appId: string, policyId: string, options?: any): ApiPromise<ListPolicyAssetsResponse> {
            return localVarFp.getAssetByPolicy(appId, policyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolicyApi - object-oriented interface
 * @export
 * @class PolicyApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Returns a list of assets with the given Policy ID. The response is paginated to make the result set easier to handle. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next batch of owners. To learn more about how pagination works, visit https://docs.tangocrypto.com/rest-api/pagination 
     * @summary List assets by policy
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} policyId Policy ID controlling an asset.
     * @param {number} [size] The number of assets to return in a single page.
     * @param {string} [cursor] A pagination cursor returned by a previous call to this endpoint. Provide this cursor to retrieve the next set of results for your original query.     
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getAssetByPolicy(appId: string, version: string, policyId: string, size?: number, cursor?: string, options?: AxiosRequestConfig) {
        return PolicyApiFp(this.configuration).getAssetByPolicy(appId, version, policyId, size, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoolsApi - axios parameter creator
 * @export
 */
export const PoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of delegations for a given stake pool. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of delegations. 
         * @summary List stake pool delegations
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} poolId Bech32 or hexadecimal pool ID.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last.          
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakePoolDelegations: async (appId: string, version: string, poolId: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('stakePoolDelegations', 'appId', appId)
            // verify required parameter 'poolId' is not null or undefined
            assertParamExists('stakePoolDelegations', 'poolId', poolId)
            const localVarPath = buildPath(appId, version, 'pools', poolId, 'delegations');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Retrieve stake pool registration metadata specified by a `pool_id`. 
         * @summary Retrieve stake pool metadata
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} poolId Bech32 or hexadecimal pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakePoolMetadata: async (appId: string, version: string, poolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('stakePoolMetadata', 'appId', appId)
            // verify required parameter 'poolId' is not null or undefined
            assertParamExists('stakePoolMetadata', 'poolId', poolId)
            const localVarPath = buildPath(appId, version, 'pools', poolId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolsApi - functional programming interface
 * @export
 */
export const PoolsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of delegations for a given stake pool. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of delegations. 
         * @summary List stake pool delegations
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} poolId Bech32 or hexadecimal pool ID.
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last.         
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakePoolDelegations(appId: string, version: string, poolId: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListPoolDelegationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakePoolDelegations(appId, version, poolId, size, cursor, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Retrieve stake pool registration metadata specified by a `pool_id`. 
         * @summary Retrieve stake pool metadata
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} poolId Bech32 or hexadecimal pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakePoolMetadata(appId: string, version: string, poolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrievePoolMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakePoolMetadata(appId, version, poolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoolsApi - factory interface
 * @export
 */
export const PoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolsApiFp(configuration)
    return {
        /**
         * Returns a list of delegations for a given stake pool. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of delegations. 
         * @summary List stake pool delegations
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} poolId Bech32 or hexadecimal pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakePoolDelegations(appId: string, poolId: string, options?: any): ApiPromise<ListPoolDelegationsResponse> {
            return localVarFp.stakePoolDelegations(appId, poolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve stake pool registration metadata specified by a `pool_id`. 
         * @summary Retrieve stake pool metadata
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} poolId Bech32 or hexadecimal pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakePoolMetadata(appId: string, poolId: string, options?: any): ApiPromise<RetrievePoolMetadataResponse> {
            return localVarFp.stakePoolMetadata(appId, poolId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
export class PoolsApi extends BaseAPI {
    /**
     * Returns a list of delegations for a given stake pool. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of delegations. 
     * @summary List stake pool delegations
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} poolId Bech32 or hexadecimal pool ID.
     * @param {number} [size] The number of results displayed on one page.
     * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
     * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last.     
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public stakePoolDelegations(appId: string, version: string, poolId: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).stakePoolDelegations(appId, version, poolId, size, cursor, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve stake pool registration metadata specified by a `pool_id`. 
     * @summary Retrieve stake pool metadata
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} poolId Bech32 or hexadecimal pool ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public stakePoolMetadata(appId: string, version: string, poolId: string, options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).stakePoolMetadata(appId, version, poolId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Build and serialize transaction with custom logic like swap, send, mint, burn etc.
         * @summary Build a transaction
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {BuildTxRequest} [buildTxRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransaction: async (appId: string, version: string, buildTxRequest?: BuildTxRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('buildTransaction', 'appId', appId)
            const localVarPath = buildPath(appId, version, 'transactions', 'build');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(buildTxRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Retrieves the information about a transaction requested specified by a transaction `hash`.
         * @summary Retrieve Transaction
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} hash Hash of the requested transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (appId: string, version: string, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getTransaction', 'appId', appId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getTransaction', 'hash', hash)
            const localVarPath = buildPath(appId, version, 'transactions', hash);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Retrieve the transaction metadata specified by a transaction `hash`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of metadata values. 
         * @summary Retrieve transaction metadata
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} hash Hash of the requested transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionMetadata: async (appId: string, version: string, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getTransactionMetadata', 'appId', appId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getTransactionMetadata', 'hash', hash)
            const localVarPath = buildPath(appId, version, 'transactions', hash, 'metadata');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * List the UTXOs from a transaction specified by a transaction `hash`.
         * @summary List transaction UTXOs
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} hash Hash of the requested transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionUtxos: async (appId: string, version: string, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listTransactionUtxos', 'appId', appId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('listTransactionUtxos', 'hash', hash)
            const localVarPath = buildPath(appId, version, 'transactions', hash, 'utxos');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit an already serialized transaction to the network.
         * @summary Submit a transaction
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {SubmitTansactionRequest} [subitTansactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTransaction: async (appId: string, version: string, subitTansactionRequest?: SubmitTansactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('submitTransaction', 'appId', appId)
            const localVarPath = buildPath(appId, version, 'transactions', 'submit');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(subitTansactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Build and serialize transaction with custom logic like swap, send, mint, burn etc.
         * @summary Build a transaction
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {BuildTxRequest} [buildTxRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTransaction(appId: string, version: string, buildTxRequest?: BuildTxRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<BuildTxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTransaction(appId, version, buildTxRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Retrieves the information about a transaction requested specified by a transaction `hash`.
         * @summary Retrieve Transaction
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} hash Hash of the requested transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(appId: string, version: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(appId, version, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Retrieve the transaction metadata specified by a transaction `hash`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of metadata values. 
         * @summary Retrieve transaction metadata
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} hash Hash of the requested transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionMetadata(appId: string, version: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveTransactionMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionMetadata(appId, version, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * List the UTXOs from a transaction specified by a transaction `hash`.
         * @summary List transaction UTXOs
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} hash Hash of the requested transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionUtxos(appId: string, version: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListTransactionUtxosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionUtxos(appId, version, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Submit an already serialized transaction to the network.
         * @summary Submit a transaction
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {SubmitTansactionRequest} [subitTansactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitTransaction(appId: string, version: string, subitTansactionRequest?: SubmitTansactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<SubitTansactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTransaction(appId, version, subitTansactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Build and serialize transaction with custom logic like swap, send, mint, burn etc.
         * @summary Build a transaction
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {BuildTxRequest} [buildTxRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransaction(appId: string, version: string, buildTxRequest?: BuildTxRequest, options?: any): ApiPromise<BuildTxResponse> {
            return localVarFp.buildTransaction(appId, version, buildTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the information about a transaction requested specified by a transaction `hash`.
         * @summary Retrieve Transaction
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} hash Hash of the requested transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(appId: string, hash: string, options?: any): ApiPromise<RetrieveTransactionResponse> {
            return localVarFp.getTransaction(appId, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the transaction metadata specified by a transaction `hash`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of metadata values. 
         * @summary Retrieve transaction metadata
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} hash Hash of the requested transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionMetadata(appId: string, hash: string, options?: any): ApiPromise<RetrieveTransactionMetadataResponse> {
            return localVarFp.getTransactionMetadata(appId, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * List the UTXOs from a transaction specified by a transaction `hash`.
         * @summary List transaction UTXOs
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} hash Hash of the requested transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionUtxos(appId: string, hash: string, options?: any): ApiPromise<ListTransactionUtxosResponse> {
            return localVarFp.listTransactionUtxos(appId, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit an already serialized transaction to the network.
         * @summary Submit a transaction
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {SubmitTansactionRequest} [subitTansactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTransaction(appId: string, version: string, subitTansactionRequest?: SubmitTansactionRequest, options?: any): ApiPromise<SubitTansactionResponse> {
            return localVarFp.submitTransaction(appId, version, subitTansactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Build and serialize transaction with custom logic like swap, send, mint, burn etc.
     * @summary Build a transaction
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {BuildTxRequest} [buildTxRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public buildTransaction(appId: string, version: string, buildTxRequest?: BuildTxRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).buildTransaction(appId, version, buildTxRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the information about a transaction requested specified by a transaction `hash`.
     * @summary Retrieve Transaction
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} hash Hash of the requested transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransaction(appId: string, version: string, hash: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransaction(appId, version, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the transaction metadata specified by a transaction `hash`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of metadata values. 
     * @summary Retrieve transaction metadata
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} hash Hash of the requested transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionMetadata(appId: string, version: string, hash: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionMetadata(appId, version, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the UTXOs from a transaction specified by a transaction `hash`.
     * @summary List transaction UTXOs
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} hash Hash of the requested transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransactionUtxos(appId: string, version: string, hash: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listTransactionUtxos(appId, version, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit an already serialized transaction to the network.
     * @summary Submit a transaction
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {SubmitTansactionRequest} [subitTansactionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public submitTransaction(appId: string, version: string, subitTansactionRequest?: SubmitTansactionRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).submitTransaction(appId, version, subitTansactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WalletsApi - axios parameter creator
 * @export
 */
export const WalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve wallet summary specified by `stake_address`.
         * @summary Retrieve wallet summary
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} stakeAddress The Bech32 encoded version of the stake address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletsStake: async (appId: string, version: string, stakeAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getWalletsStake', 'appId', appId)
            // verify required parameter 'stakeAddress' is not null or undefined
            assertParamExists('getWalletsStake', 'stakeAddress', stakeAddress)
            const localVarPath = buildPath(appId, version, 'wallets', stakeAddress);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of addreses for a given wallet `stake_address`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of addresses. 
         * @summary List wallet addresses
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} stakeAddress 
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStakeAddressAddresses: async (appId: string, version: string, stakeAddress: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listStakeAddressAddresses', 'appId', appId)
            // verify required parameter 'stakeAddress' is not null or undefined
            assertParamExists('listStakeAddressAddresses', 'stakeAddress', stakeAddress)
            const localVarPath = buildPath(appId, version, 'wallets', stakeAddress, 'addresses');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletsApi - functional programming interface
 * @export
 */
export const WalletsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve wallet summary specified by `stake_address`.
         * @summary Retrieve wallet summary
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} stakeAddress The Bech32 encoded version of the stake address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletsStake(appId: string, version: string, stakeAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveWalletSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletsStake(appId, version, stakeAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of addreses for a given wallet `stake_address`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of addresses. 
         * @summary List wallet addresses
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} stakeAddress 
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStakeAddressAddresses(appId: string, version: string, stakeAddress: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListWalletAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStakeAddressAddresses(appId, version, stakeAddress, size, cursor, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WalletsApi - factory interface
 * @export
 */
export const WalletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletsApiFp(configuration)
    return {
        /**
         * Retrieve wallet summary specified by `stake_address`.
         * @summary Retrieve wallet summary
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} stakeAddress The Bech32 encoded version of the stake address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletsStake(appId: string, version: string, stakeAddress: string, options?: any): ApiPromise<RetrieveWalletSummaryResponse> {
            return localVarFp.getWalletsStake(appId, version, stakeAddress, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of addreses for a given wallet `stake_address`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of addresses. 
         * @summary List wallet addresses
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {string} stakeAddress 
         * @param {number} [size] The number of results displayed on one page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStakeAddressAddresses(appId: string, version: string, stakeAddress: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: any): ApiPromise<ListWalletAddressesResponse> {
            return localVarFp.listStakeAddressAddresses(appId, version, stakeAddress, size, cursor, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export class WalletsApi extends BaseAPI {
    /**
     * Retrieve wallet summary specified by `stake_address`.
     * @summary Retrieve wallet summary
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} stakeAddress The Bech32 encoded version of the stake address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public getWalletsStake(appId: string, version: string, stakeAddress: string, options?: AxiosRequestConfig) {
        return WalletsApiFp(this.configuration).getWalletsStake(appId, version, stakeAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of addreses for a given wallet `stake_address`. The response is paginated. If truncated, the response includes a cursor that you use in a subsequent request to retrieve the next set of addresses. 
     * @summary List wallet addresses
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} stakeAddress 
     * @param {number} [size] The number of results displayed on one page.
     * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
     * @param {'asc' | 'desc'} [order] The ordering of items from the point of view of the blockchain. By default, we return oldest first, newest last. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public listStakeAddressAddresses(appId: string, version: string, stakeAddress: string, size?: number, cursor?: string, order?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return WalletsApiFp(this.configuration).listStakeAddressAddresses(appId, version, stakeAddress, size, cursor, order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create Webhook
         * @summary Create Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (appId: string, version: string, createWebhookRequest?: CreateWebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createWebhook', 'appId', appId)
            const localVarPath = buildPath(appId, version, 'webhooks');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Deletes a single Webhook based on the provided ID.
         * @summary Delete Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (appId: string, version: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteWebhook', 'appId', appId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = buildPath(appId, version, 'webhooks', webhookId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Returns a list of webhooks created in your Tangocrypto account. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of webhooks. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
         * @summary List Webhooks
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {number} [size] The number of webhooks to return in a single page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (appId: string, version: string, size?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listWebhooks', 'appId', appId)
            const localVarPath = buildPath(appId, version, 'webhooks');
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Get details for a single Webhook in your Tangocrypto account.
         * @summary Retrieve Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} webhookId The ID of the webhook to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebhook: async (appId: string, version: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('retrieveWebhook', 'appId', appId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('retrieveWebhook', 'webhookId', webhookId)
            const localVarPath = `/{app_id}/v1/webhooks/{webhook_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

        /**
         * Updates the webbook without having to perform an upsert on the entire item. Just include include the fields you want to be updated in the request body.
         * @summary Update Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} webhookId The ID of the webhook to update.
         * @param {UpdateWebhookRequest} [updateWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (appId: string, version: string, webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateWebhook', 'appId', appId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            const localVarPath = buildPath(appId, version, 'webhooks', webhookId);
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication x-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create Webhook
         * @summary Create Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;
         * @param {string} version Tangocrypto version.         
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(appId: string, version: string, createWebhookRequest?: CreateWebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<CreateWebhooksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(appId, version, createWebhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Deletes a single Webhook based on the provided ID.
         * @summary Delete Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(appId: string, version: string, webhookId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<DeleteWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(appId, version, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Returns a list of webhooks created in your Tangocrypto account. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of webhooks. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
         * @summary List Webhooks
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {number} [size] The number of webhooks to return in a single page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(appId: string, version: string, size?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<ListWebhooksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(appId, version, size, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Get details for a single Webhook in your Tangocrypto account.
         * @summary Retrieve Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.          
         * @param {string} webhookId The ID of the webhook to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveWebhook(appId: string, version: string, webhookId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<RetrieveWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveWebhook(appId, version, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },

        /**
         * Updates the webbook without having to perform an upsert on the entire item. Just include include the fields you want to be updated in the request body.
         * @summary Update Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version. 
         * @param {string} webhookId The ID of the webhook to update.
         * @param {UpdateWebhookRequest} [updateWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(appId: string, version: string, webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => ApiPromise<UpdateWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(appId, version, webhookId, updateWebhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create Webhook
         * @summary Create Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(appId: string, version: string, createWebhookRequest?: CreateWebhookRequest, options?: any): ApiPromise<CreateWebhooksResponse> {
            return localVarFp.createWebhook(appId, version, createWebhookRequest, options).then((request) => request(axios, basePath));
        },

        /**
         * Deletes a single Webhook based on the provided ID.
         * @summary Delete Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(appId: string, version: string, webhookId: string, options?: any): ApiPromise<DeleteWebhookResponse> {
            return localVarFp.deleteWebhook(appId, version, webhookId, options).then((request) => request(axios, basePath));
        },

        /**
         * Returns a list of webhooks created in your Tangocrypto account. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of webhooks. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
         * @summary List Webhooks
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {number} [size] The number of webhooks to return in a single page.
         * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(appId: string, version: string, size?: number, cursor?: string, options?: any): ApiPromise<ListWebhooksResponse> {
            return localVarFp.listWebhooks(appId, version, size, cursor, options).then((request) => request(axios, basePath));
        },

        /**
         * Get details for a single Webhook in your Tangocrypto account.
         * @summary Retrieve Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.         
         * @param {string} webhookId The ID of the webhook to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebhook(appId: string, version: string, webhookId: string, options?: any): ApiPromise<RetrieveWebhookResponse> {
            return localVarFp.retrieveWebhook(appId, version, webhookId, options).then((request) => request(axios, basePath));
        },

        /**
         * Updates the webbook without having to perform an upsert on the entire item. Just include include the fields you want to be updated in the request body.
         * @summary Update Webhook
         * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
         * @param {string} version Tangocrypto version.        
         * @param {string} webhookId The ID of the webhook to update.
         * @param {UpdateWebhookRequest} [updateWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(appId: string, version: string, webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: any): ApiPromise<UpdateWebhookResponse> {
            return localVarFp.updateWebhook(appId, version, webhookId, updateWebhookRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create Webhook
     * @summary Create Webhook
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {CreateWebhookRequest} [createWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWebhook(appId: string, version: string, createWebhookRequest?: CreateWebhookRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).createWebhook(appId, version, createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single Webhook based on the provided ID.
     * @summary Delete Webhook
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(appId: string, version: string, webhookId: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(appId, version, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of webhooks created in your Tangocrypto account. The response is paginated. If truncated, the response includes a `cursor` that you use in a subsequent request to retrieve the next set of webhooks. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @summary List Webhooks
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {number} [size] The number of webhooks to return in a single page.
     * @param {string} [cursor] A &#x60;cursor&#x60; to access the next set of results. You include the cursor in subsequent requests to the endpoint as a URL query parameter of your request. If the cursor is empty in the result it means there are no more items to be retrieved. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public listWebhooks(appId: string, version: string, size?: number, cursor?: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).listWebhooks(appId, version, size, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details for a single Webhook in your Tangocrypto account.
     * @summary Retrieve Webhook
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.     
     * @param {string} webhookId The ID of the webhook to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public retrieveWebhook(appId: string, version: string, webhookId: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).retrieveWebhook(appId, version, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the webbook without having to perform an upsert on the entire item. Just include include the fields you want to be updated in the request body.
     * @summary Update Webhook
     * @param {string} appId Tangocrypto &#x60;app_id&#x60;.
     * @param {string} version Tangocrypto version.
     * @param {string} webhookId The ID of the webhook to update.
     * @param {UpdateWebhookRequest} [updateWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhook(appId: string, version: string, webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).updateWebhook(appId, version, webhookId, updateWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
}