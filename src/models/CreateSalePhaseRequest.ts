/* tslint:disable */
/* eslint-disable */
/**
 * Tangocrypto API
 * ## Overview  Tangocrypto API(Application Programing Interface) allows you fast and reliable access to the Cardano network that requires only minutes to integrate.    ## API Key header   When you sign up on https://www.tangocrypto.com and create an App an `x-api-key` is created. You must include the HTTP header `x-api-key` in every request in order to authenticate the API calls.   ## Network and Account ID   You can choose the mainnet or the testnet for your queries. The API requires a valid `app_id` to be included with your request traffic. This identifier should be appended to the request URL.   <table>    <tr><td><b>Network</b></td><td><b>Endpoint</b></td></tr>    <tr><td>Cardano mainnet</td><td><tt>https://cardano-mainnet.tangocrypto.com/{app_id}/v1</td></tt></tr>    <tr><td>Cardano testnet</td><td><tt>https://cardano-testnet.tangocrypto.com/{app_id}/v1</tt></td></tr>  </table>   ## Errors   ### HTTP Status codes   These are the response codes you are going to get when you query Tangocrypto API.   <table>    <tr><td><b>Code</b></td><td><b>Meaning</b></td></tr>    <tr><td><tt><strong>400</strong></tt></td><td><strong>Bad Request</strong> - Your request is invalid. </td></tr>    <tr><td><tt><strong>401</strong></tt></td><td><strong>Unauthorized</strong> - You must authenticate your request with an API key. Check out how to create a key if you do not have one. </td></tr>    <tr><td><tt><strong>403</strong></tt></td><td><strong>Forbidden</strong> - Check you are using the right API KEY, or you\'ve hit your capacity limit, or your request was rejected by your app\'s whitelist settings. </td></tr>    <tr><td><tt><strong>404</strong></tt></td><td><strong>Not found</strong> - Endpoint not found. </td></tr>    <tr><td><tt><strong>429</strong></tt></td><td><strong>Too Many Requests</strong> - You\'ve exceeded your concurrent requests capacity. Check out the Rate Limits page for solutions.</td></tr>    <tr><td><tt><strong>500</strong></tt></td><td><strong>Internal Server Error</strong> - We\'re unable to process your request right now. Get in touch with us if you see this.</td></tr>  </table>  
 *
 * The version of the OpenAPI document: 1
 * Contact: contact@tangocrypto.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { CreateSalePhaseRequestPriceTiersInner } from './CreateSalePhaseRequestPriceTiersInner';
import {
    CreateSalePhaseRequestPriceTiersInnerFromJSON,
    CreateSalePhaseRequestPriceTiersInnerFromJSONTyped,
    CreateSalePhaseRequestPriceTiersInnerToJSON,
} from './CreateSalePhaseRequestPriceTiersInner';
import type { CreateSalePhaseRequestTokensInner } from './CreateSalePhaseRequestTokensInner';
import {
    CreateSalePhaseRequestTokensInnerFromJSON,
    CreateSalePhaseRequestTokensInnerFromJSONTyped,
    CreateSalePhaseRequestTokensInnerToJSON,
} from './CreateSalePhaseRequestTokensInner';

/**
 * 
 * @export
 * @interface CreateSalePhaseRequest
 */
export interface CreateSalePhaseRequest {
    /**
     * Sale phase name. For example, pre-sale.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    name?: string;
    /**
     * <br /> Use `fixed` for selling a particular token or token list identified by the token-id on each token. 
     * <br /> Use `random` for random sales, it will pick random tokens from the collection.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    type: CreateSalePhaseRequestTypeEnum;
    /**
     * Defines how many NFTs you will sell in this phase. For example, you are doing a pre-sale, and you want to sell 1000 NFTs.
     * @type {number}
     * @memberof CreateSalePhaseRequest
     */
    totalTokens: number;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won't be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {number}
     * @memberof CreateSalePhaseRequest
     */
    reservationTime?: number;
    /**
     * Starting date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don't provide this value you can start selling immediately.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    startDate?: string;
    /**
     * Ending date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don't provide this value, there is no time boundary; thus, you can sell NFTs until you reach the collection's total amount.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    endDate?: string;
    /**
     * (Used in `random` sale phases). Create price tiers per sale phase. A price tier is a way to create bundles and sell them for different prices. For example, you can create a price tier with 10 NFTs for 100 ADA, and the buyer will pay 100 ADA and receive 10 NFTs in their wallet. You can create up to 10 price tiers per sale phase.'
     * @type {Array<CreateSalePhaseRequestPriceTiersInner>}
     * @memberof CreateSalePhaseRequest
     */
    priceTiers?: Array<CreateSalePhaseRequestPriceTiersInner>;
    /**
     * (Used in `fixed` sale phases). Individual tokens to include in a sale phase.
     * @type {Array<CreateSalePhaseRequestTokensInner>}
     * @memberof CreateSalePhaseRequest
     */
    tokens?: Array<CreateSalePhaseRequestTokensInner>;
}


/**
 * @export
 */
export const CreateSalePhaseRequestTypeEnum = {
    Fixed: 'fixed',
    Random: 'random'
} as const;
export type CreateSalePhaseRequestTypeEnum = typeof CreateSalePhaseRequestTypeEnum[keyof typeof CreateSalePhaseRequestTypeEnum];


/**
 * Check if a given object implements the CreateSalePhaseRequest interface.
 */
export function instanceOfCreateSalePhaseRequest(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "type" in value;
    isInstance = isInstance && "totalTokens" in value;

    return isInstance;
}

export function CreateSalePhaseRequestFromJSON(json: any): CreateSalePhaseRequest {
    return CreateSalePhaseRequestFromJSONTyped(json, false);
}

export function CreateSalePhaseRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): CreateSalePhaseRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'name': !exists(json, 'name') ? undefined : json['name'],
        'type': json['type'],
        'totalTokens': json['total_tokens'],
        'reservationTime': !exists(json, 'reservation_time') ? undefined : json['reservation_time'],
        'startDate': !exists(json, 'start_date') ? undefined : json['start_date'],
        'endDate': !exists(json, 'end_date') ? undefined : json['end_date'],
        'priceTiers': !exists(json, 'price_tiers') ? undefined : ((json['price_tiers'] as Array<any>).map(CreateSalePhaseRequestPriceTiersInnerFromJSON)),
        'tokens': !exists(json, 'tokens') ? undefined : ((json['tokens'] as Array<any>).map(CreateSalePhaseRequestTokensInnerFromJSON)),
    };
}

export function CreateSalePhaseRequestToJSON(value?: CreateSalePhaseRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'name': value.name,
        'type': value.type,
        'total_tokens': value.totalTokens,
        'reservation_time': value.reservationTime,
        'start_date': value.startDate,
        'end_date': value.endDate,
        'price_tiers': value.priceTiers === undefined ? undefined : ((value.priceTiers as Array<any>).map(CreateSalePhaseRequestPriceTiersInnerToJSON)),
        'tokens': value.tokens === undefined ? undefined : ((value.tokens as Array<any>).map(CreateSalePhaseRequestTokensInnerToJSON)),
    };
}

