/**
 * 
 * @export
 * @interface AffiliateSummary
 */
 export interface AffiliateSummary {
    /**
     * Affiliate id
     * @type {string}
     * @memberof AffiliateSummary
     */
    'id'?: string;
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof AffiliateSummary
     */
    'name'?: string;
    /**
     * The value is `true` if the affiliate is active and `false` if it is not.
     * @type {boolean}
     * @memberof AffiliateSummary
     */
    'active'?: boolean;
    /**
     * If set to `true`, the funds are transferred automatically to the affiliate every time a customer purchases an NFT.
     * @type {boolean}
     * @memberof AffiliateSummary
     */
    'automatic_payout'?: boolean;
    /**
     * The wallet address of the affiliate. The revenue made from the affiliate sales goes to this address.
     * @type {string}
     * @memberof AffiliateSummary
     */
    'address'?: string;
    /**
     * The total amount of ADA generated by the sale. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {number}
     * @memberof AffiliateSummary
     */
    'revenue'?: number;
    /**
     * Income made by the affiliate from the sale. This is the amount of Ada (in Lovelaces) that goes to the affiliate wallet. For example, if the affiliate sells a package of 4 NFTs for 40 Ada and the commission rate is 20% the income will be 8000000 Lovelaces.
     * @type {number}
     * @memberof AffiliateSummary
     */
    'income'?: number;
    /**
     * Commission rate made by the affiliate. If the `commision_type` is `flat` here, you have to specify the commission in Lovelaces. If the commission_type is set to `percentage`, then here you type the percentage. For example, 0.2 represents 20%.
     * @type {number}
     * @memberof AffiliateSummary
     */
    'commission'?: number;
    /**
     * There are two types of commission types, `fla`t and `percentage`. Use `flat` commission if you want to pay a flat rate on every sale. For example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the commission is set to 10 Ada, the affiliate will receive 10 Ada. Use percentage commission if you want to pay a percentage on every sale; for example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the 1commission1 is set to 20% the affiliate will receive 20 Ada.
     * @type {string}
     * @memberof AffiliateSummary
     */
    'commission_type'?: string;
    /**
     * Amount of sales made by the affiliate.
     * @type {number}
     * @memberof AffiliateSummary
     */
    'sale_count'?: number;
}

/**
 * 
 * @export
 * @interface CancelNftSaleResponse
 */
 export interface CancelNftSaleResponse {
    /**
     * Return `true` if the sale was canceled succesfully.
     * @type {boolean}
     * @memberof CancelNftSaleResponse
     */
    'canceled'?: boolean;
    /**
     * Cancelled sale id.
     * @type {string}
     * @memberof CancelNftSaleResponse
     */
    'canceled_sale_id'?: string;
    /**
     * Cancelation timestamp.
     * @type {string}
     * @memberof CancelNftSaleResponse
     */
    'canceled_at'?: string;
}
/**
 * 
 * @export
 * @interface CheckAddressListRequest
 */
export interface CheckAddressListRequest {
    /**
     * Bech32 address.
     * @type {string}
     * @memberof CheckAddressListRequest
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface CollectionDeleteResponse
 */
export interface CollectionDeleteResponse {
    /**
     * Returns `true` if successfuly deleted or `false` if there was an error deleting the collection.
     * @type {boolean}
     * @memberof CollectionDeleteResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted collection ID.
     * @type {string}
     * @memberof CollectionDeleteResponse
     */
    'deleted_collection_id'?: string;
    /**
     * Deletion datetime in ISO 8601 format.
     * @type {string}
     * @memberof CollectionDeleteResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateAddressListResponse
 */
export interface CreateAddressListResponse {
    /**
     * Address list id.
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'name'?: string;
    /**
     * Address list name.
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'description'?: string;
    /**
     * Size in bytes.
     * @type {number}
     * @memberof CreateAddressListResponse
     */
    'size'?: number;
    /**
     * Number of items.
     * @type {number}
     * @memberof CreateAddressListResponse
     */
    'items'?: number;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateAddressListResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateAffiliateRequest
 */
export interface CreateAffiliateRequest {
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof CreateAffiliateRequest
     */
    'name': string;
    /**
     * The value is `true` if the affiliate is active and `false` if it is not.
     * @type {boolean}
     * @memberof CreateAffiliateRequest
     */
    'active'?: boolean;
    /**
     * If set to `true`, the funds are transferred automatically to the affiliate every time a customer purchases an NFT.
     * @type {boolean}
     * @memberof CreateAffiliateRequest
     */
    'automatic_payout'?: boolean;
    /**
     * The wallet address of the affiliate. The revenue made from the affiliate sales goes to this address.
     * @type {string}
     * @memberof CreateAffiliateRequest
     */
    'address': string;
    /**
     * Commission rate made by the affiliate. If the `commision_type` is `flat` here, you have to specify the commission in Lovelaces. If the `commission_type` is set to `percentage`, then here you type the percentage. For example, 0.2 represents 20%.
     * @type {number}
     * @memberof CreateAffiliateRequest
     */
    'commission': number;
    /**
     * There are two types of commission types, `flat` and `percentage`. Use `flat` commission if you want to pay a flat rate on every sale. For example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the `commission` is set to 10 Ada, the affiliate will receive 10 Ada.  Use `percentage` commission if you want to pay a percentage on every sale; for example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the 1commission1 is set to 20% the affiliate will receive 20 Ada.
     * @type {string}
     * @memberof CreateAffiliateRequest
     */
    'commission_type': CreateAffiliateRequestCommissionTypeEnum;
}
/**
 * 
 * @export
 * @interface UpdateAffiliateRequest
 */
export interface UpdateAffiliateRequest {
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof UpdateAffiliateRequest
     */
    'name'?: string;
    /**
     * The value is `true` if the affiliate is active and `false` if it is not.
     * @type {boolean}
     * @memberof UpdateAffiliateRequest
     */
    'active'?: boolean;
    /**
     * If set to `true`, the funds are transferred automatically to the affiliate every time a customer purchases an NFT.
     * @type {boolean}
     * @memberof UpdateAffiliateRequest
     */
    'automatic_payout'?: boolean;
}

/**
 * 
 * @export
 * @interface CreatePriceTierRequest
 */
export interface CreatePriceTierRequest {
    /**
     * Price tier name. Used to identify the price tier.
     * @type {string}
     * @memberof CreatePriceTierRequest
     */
    'name': string;
    /**
     * Price tier price. How much paid for buying with this price tier.
     * @type {number}
     * @memberof CreatePriceTierRequest
     */
    'price': number;
    /**
     * Price tier quantity. How many tokens will be sold with this price tier.
     * NOTE: Cannot create sales with more than 20 tokens
     * @type {number}
     * @memberof CreatePriceTierRequest
     */
    'quantity': number;
    /**
     * Price tier supply. Amount of token supply when minted, default to 1.
     * @type {number}
     * @memberof CreatePriceTierRequest
     */
    'supply'?: number;
    /**
     * Price tier tokens. Individual tokens to include in a price tier.
     * NOTE: Tokens batch size must be less than or equal to 20
     * @type {Array<number>}
     * @memberof CreatePriceTierRequest
     */
    'tokens'?: Array<string>;
}

/**
 * 
 * @export
 * @interface CreatePriceTierResponse
 */
export interface CreatePriceTierResponse {
    /**
     * Price Tier id.
     * @type {string}
     * @memberof CreatePriceTierResponse
     */
    id: string;
    /**
     * Price Tier name.
     * @type {string}
     * @memberof CreatePriceTierResponse
     */
    name: string;
    /**
     * Price Tier price.
     * @type {number}
     * @memberof CreatePriceTierResponse
     */
    price: number;
    /**
     * Price Tier quantity.
     * @type {number}
     * @memberof CreatePriceTierResponse
     */
    quantity: number;
    /**
     * Price Tier supply.
     * @type {number}
     * @memberof CreatePriceTierResponse
     */
    supply: number;
    /**
     * Price Tier tokens.
     * @type {Array<string>}
     * @memberof CreatePriceTierResponse
     */
    tokens: Array<string>;
    /**
     * Price Tier token sold count.
     * @type {number}
     * @memberof CreatePriceTierResponse
     */
    token_sold_count: number;
}

/**
* 
* @export
* @interface UpdatePriceTierRequest
*/
export interface UpdatePriceTierRequest {
    /**
     * Price tier name. Used to identify the price tier.
     * @type {string}
     * @memberof UpdatePriceTierRequest
     */
    'name'?: string;
    /**
     * Price tier price. How much paid for buying with this price tier.
     * @type {number}
     * @memberof UpdatePriceTierRequest
     */
    'price'?: number;
    /**
     * Price tier quantity. How many tokens will be sold with this price tier. 
     * NOTE: Cannot create sales with more than 20 tokens
     * @type {number}
     * @memberof UpdatePriceTierRequest
     */
    'quantity'?: number;
    /**
     * Price tier supply. Amount of token supply when minted, default to 1.
     * @type {number}
     * @memberof UpdatePriceTierRequest
     */
    'supply'?: number;
    /**
     * Price tier tokens. Individual tokens to include in a price tier.
     * NOTE: Tokens batch size must be less than or equal to 20     
     * @type {Array<number>}
     * @memberof UpdatePriceTierRequest
     */
    'tokens'?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdatePriceTierResponse
 */
export interface UpdatePriceTierResponse {
    /**
     * Price Tier id.
     * @type {string}
     * @memberof UpdatePriceTierResponse
     */
    id: string;
    /**
     * Price Tier name.
     * @type {string}
     * @memberof UpdatePriceTierResponse
     */
    name: string;
    /**
     * Price Tier price.
     * @type {number}
     * @memberof UpdatePriceTierResponse
     */
    price: number;
    /**
     * Price Tier quantity.
     * @type {number}
     * @memberof UpdatePriceTierResponse
     */
    quantity: number;
    /**
     * Price Tier supply.
     * @type {number}
     * @memberof UpdatePriceTierResponse
     */
    supply: number;
    /**
     * Price Tier tokens.
     * @type {Array<string>}
     * @memberof UpdatePriceTierResponse
     */
    tokens: Array<string>;
    /**
     * Price Tier token sold count.
     * @type {number}
     * @memberof UpdatePriceTierResponse
     */
    token_sold_count: number;
}


/**
 * 
 * @export
 * @interface DeletePriceTierResponse
 */
export interface DeletePriceTierResponse {
    /**
     * Returns `true` if successfuly deleted or `false` if there was an error deleting the price tier.
     * @type {boolean}
     * @memberof DeletePriceTierResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted price tier ID
     * @type {string}
     * @memberof DeletePriceTierResponse
     */
    'deleted_affiliate_id'?: string;
    /**
     * Deletion datetime in ISO 8601 format.
     * @type {string}
     * @memberof DeletePriceTierResponse
     */
    'deleted_at'?: string;
}

export const CreateAffiliateRequestCommissionTypeEnum = {
    Flat: 'flat',
    Percentage: 'percentage'
} as const;

export type CreateAffiliateRequestCommissionTypeEnum = typeof CreateAffiliateRequestCommissionTypeEnum[keyof typeof CreateAffiliateRequestCommissionTypeEnum];

/**
 * 
 * @export
 * @interface CreateAffiliateResponse
 */
export interface CreateAffiliateResponse {
    /**
     * affiliate id
     * @type {string}
     * @memberof CreateAffiliateResponse
     */
    'id'?: string;
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof CreateAffiliateResponse
     */
    'name'?: string;
    /**
     * The value is `true` if the affiliate is active and `false` if it is not.
     * @type {boolean}
     * @memberof CreateAffiliateResponse
     */
    'active'?: boolean;
    /**
     * If set to `true`, the funds are transferred automatically to the affiliate every time a customer purchases an NFT.
     * @type {boolean}
     * @memberof CreateAffiliateResponse
     */
    'automatic_payout'?: boolean;
    /**
     * The wallet address of the affiliate. The revenue made from the affiliate sales goes to this address.
     * @type {string}
     * @memberof CreateAffiliateResponse
     */
    'address'?: string;
    /**
     * The total amount of ADA generated by the sale. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {number}
     * @memberof CreateAffiliateResponse
     */
    'revenue'?: number;
    /**
     * Income made by the affiliate from the sale. This is the amount of Ada (in Lovelaces) that goes to the affiliate wallet. For example, if the affiliate sells a package of 4 NFTs for 40 Ada and the commission rate is 20% the income will be 8000000 Lovelaces.
     * @type {number}
     * @memberof CreateAffiliateResponse
     */
    'income'?: number;
    /**
     * Commission rate made by the affiliate. If the `commision_type` is `flat` here, you have to specify the commission in Lovelaces. If the `commission_type` is set to `percentage`, then here you type the percentage. For example, 0.2 represents 20%.
     * @type {number}
     * @memberof CreateAffiliateResponse
     */
    'commission'?: number;
    /**
     * There are two types of commission types, `flat` and `percentag`e. Use `flat` commission if you want to pay a flat rate on every sale. For example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the `commission` is set to 10 Ada, the affiliate will receive 10 Ada.  Use `percentage` commission if you want to pay a percentage on every sale; for example, if the affiliate link leads to a sale of 5 NFTs for 100 Ada and the 1commission1 is set to 20% the affiliate will receive 20 Ada.
     * @type {string}
     * @memberof CreateAffiliateResponse
     */
    'commission_type'?: string;
    /**
     * Amount of sales made by the affiliate.
     * @type {number}
     * @memberof CreateAffiliateResponse
     */
    'sale_count'?: number;
}
/**
 * Create NFT Collection request
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * Collection name. The collection name is internal to your Tangocrypto account. This is just a way to identify different collections.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'name': string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'url'?: string;
    /**
     * 
     * @type {CreateCollectionRequestPayoutAddress}
     * @memberof CreateCollectionRequest
     */
    'payout_address': CreateCollectionRequestPayoutAddress;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    'reservation_time'?: number;
    /**
     * 
     * @type {CreateCollectionRequestPolicy}
     * @memberof CreateCollectionRequest
     */
    'policy': CreateCollectionRequestPolicy;
    /**
     * 
     * @type {CreateCollectionRequestMetadata}
     * @memberof CreateCollectionRequest
     */
    'metadata'?: CreateCollectionRequestMetadata;
    /**
     * 
     * @type {CreateCollectionRequestRoyalty}
     * @memberof CreateCollectionRequest
     */
    'royalty'?: CreateCollectionRequestRoyalty;
}
/**
 * Metadata tags for the collection. The values between `< >` mean that they are tags. A tag is simply a variable that we will assign its value when you mint the NFT. You can use the metadata tag to define common attributes shared by all the NFTs in the collection, like the name, copyright, date issued, artist name, social media links, etc. Using metadata tags is not mandatory because you can define all the attributes while creating the individual NFTs. For more details about Metadata have a look at the CIP (https://cips.cardano.org/cips/cip25/) 
 * @export
 * @interface CreateCollectionRequestMetadata
 */
export interface CreateCollectionRequestMetadata {
    /**
     * Metadata tag for the NFT asset name.
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'asset_name'?: string;
    /**
     * Metadata tag for the file name.
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'name': string;
    /**
     * Metadata tag for the NFT description.
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'description'?: string;
    /**
     * Metadata tag for the media type (also known as a Multipurpose Internet Mail Extensions or MIME type) indicates the nature and format of a document, file, or assortment of bytes. It is common to have NFTs with MIME-type imag, audio and video.
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'media_type'?: string;
    /**
     * Array of files used for files. This is used when you want to create an NFT with different file formats. For example, you can create several audio files and add them to the metadata.
     * @type {Array<CreateCollectionRequestMetadataFilesInner>}
     * @memberof CreateCollectionRequestMetadata
     */
    'files'?: Array<CreateCollectionRequestMetadataFilesInner>;
    /**
     * Custom attributes or traits for an NFT. You can create 2 types of attributes, fixed or variables.  <br /> **Fixed**: We include these attributes in the metadata of every NFT minted in the collection with a fixed value. You can add attributes like artist name, Twitter, Discord, copyright etc. You define their value here, and then you don\'t have to submit them during the NFT creation step.  <br /> **Variables**: Here you define a tag, which means that we\'ll replace this tag with a value you\'ll have to provide during the NFT creation step. As you can see in the example, we defined five traits (colour, body, eyes, face, and accesory), but we don\'t specify the value, just a tag between the angle brackets`<>`. 
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'attributes'?: string;
    /**
     * Metadata version
     * @type {string}
     * @memberof CreateCollectionRequestMetadata
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface CreateCollectionRequestMetadataFilesInner
 */
export interface CreateCollectionRequestMetadataFilesInner {
    /**
     * Asset name of the file
     * @type {string}
     * @memberof CreateCollectionRequestMetadataFilesInner
     */
    'name'?: string;
    /**
     * Metadata tag for the media type.
     * @type {string}
     * @memberof CreateCollectionRequestMetadataFilesInner
     */
    'media_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionRequestMetadataFilesInner
     */
    'src'?: string;
}
/**
 * @type CreateCollectionRequestPayoutAddress
 * @export
 */
export type CreateCollectionRequestPayoutAddress = Array<NftCollectionPayoutAddressOneOfInner> | string;

/**
 * Policy configuration for every NFT in the collection. When you create a new collection we do several steps in the background; we create a new key pair (*public verification key/private signing key*), a *policy script* and the *policy id*. Then during the sale process, all the tokens are minted with the same *policy script* and the *policy id* is attached permanently to the NFT.  
 * @export
 * @interface CreateCollectionRequestPolicy
 */
export interface CreateCollectionRequestPolicy {
    /**
     * Defines if the policy will be locked or not. If you select `false` then you are not required to chose a date and time to lock the policy, therefore the policy will be open and you can be minting NFTs under this policy forever. If you set this parameter to `true` then you have to specify a `locktime` date. 
     * @type {boolean}
     * @memberof CreateCollectionRequestPolicy
     */
    'lock': CreateCollectionRequestPolicyLockEnum;
    /**
     * Locktime date in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. It defines how long you\'ll be able to mint NFTs for the collection. The policy will lock after that date, and you won\'t be able to mint more NFTs using the same policy id (even if you use the same key). Hours and minutes are optional; if you set it to `2022-02-24`, it will automatically fill it with 0s, for example, `2022-02-24T00:00:00.000Z`. Take into consideration the desirability and size of your collection before setting this date and leave enough time for selling the NFTs. There is no limited time for the future. 
     * @type {string}
     * @memberof CreateCollectionRequestPolicy
     */
    'lock_time'?: string;
}

export const CreateCollectionRequestPolicyLockEnum = {
    True: true,
    False: false
} as const;

export type CreateCollectionRequestPolicyLockEnum = typeof CreateCollectionRequestPolicyLockEnum[keyof typeof CreateCollectionRequestPolicyLockEnum];

/**
 * 
 * @export
 * @interface CreateCollectionRequestRoyalty
 */
export interface CreateCollectionRequestRoyalty {
    /**
     * Bech32 address split in a two-element array. Each element in the array must have up to 64 bytes.
     * @type {Array<string>}
     * @memberof CreateCollectionRequestRoyalty
     */
    'address'?: Array<string>;
    /**
     * Percentage of the sale price earned each time your NFT creation is sold on a marketplace. For example, 0.05 represents 5%.
     * @type {number}
     * @memberof CreateCollectionRequestRoyalty
     */
    'rate'?: number;
}
/**
 * NFT Collection
 * @export
 * @interface CreateCollectionResponse
 */
export interface CreateCollectionResponse {
    /**
     * Collection ID.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'id'?: string;
    /**
     * Collection name.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'name'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'url'?: string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'description'?: string;
    /**
     * Wallet address that is going to receive the payments of the NFT sale.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'payout_address'?: string;
    /**
     * Amount of tokens in the collection.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'token_count'?: number;
    /**
     * Amount of tokens for sale.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'token_for_sale_count'?: number;
    /**
     * Amount of tokens sold.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'token_sold_count'?: number;
    /**
     * The total amount of ADA generated by the sale of NFTs in the collection. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'revenue'?: number;
    /**
     * The total amount of ADA generated by the sale of NFTs that goest to the seller.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'income'?: number;
    /**
     * Tangocrypto service fee. This fee depends on your plan and the number of NFTs minted. Check the price page to get more information about it.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'service_fee'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'nft_fee'?: number;
    /**
     * Transaction fees.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent in fees. This includes transaction fees, nft fees and the service fees.
     * @type {number}
     * @memberof CreateCollectionResponse
     */
    'total_fees'?: number;
    /**
     * 
     * @type {NftCollectionPolicy}
     * @memberof CreateCollectionResponse
     */
    'policy'?: NftCollectionPolicy;
    /**
     * 
     * @type {NftCollectionMetadata}
     * @memberof CreateCollectionResponse
     */
    'metadata'?: NftCollectionMetadata;
    /**
     * 
     * @type {CreateCollectionResponseRoyalty}
     * @memberof CreateCollectionResponse
     */
    'royalty'?: CreateCollectionResponseRoyalty;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateCollectionResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponseRoyalty
 */
export interface CreateCollectionResponseRoyalty {
    /**
     * 
     * @type {CreateCollectionResponseRoyaltyMetadata}
     * @memberof CreateCollectionResponseRoyalty
     */
    'metadata'?: CreateCollectionResponseRoyaltyMetadata;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponseRoyaltyMetadata
 */
export interface CreateCollectionResponseRoyaltyMetadata {
    /**
     * 
     * @type {CreateCollectionResponseRoyaltyMetadata777}
     * @memberof CreateCollectionResponseRoyaltyMetadata
     */
    '777'?: CreateCollectionResponseRoyaltyMetadata777;
}
/**
 * 
 * @export
 * @interface CreateCollectionResponseRoyaltyMetadata777
 */
export interface CreateCollectionResponseRoyaltyMetadata777 {
    /**
     * Bech32 address split in a two-element array. Each element in the array must have up to 64 bytes.
     * @type {Array<string>}
     * @memberof CreateCollectionResponseRoyaltyMetadata777
     */
    'addr'?: Array<string>;
    /**
     * Percentage of the sale price earned each time your NFT creation is sold on a marketplace. For example, 0.05 represents 5%.
     * @type {number}
     * @memberof CreateCollectionResponseRoyaltyMetadata777
     */
    'rate'?: number;
}
/**
 * Token request
 * @export
 * @interface CreateNftRequest
 */
export interface CreateNftRequest {
    /**
     * Array of tokens. You can upload a maximum of 25 tokens in a single request.
     * @type {Array<CreateNftRequestTokensInner>}
     * @memberof CreateNftRequest
     */
    'tokens': Array<CreateNftRequestTokensInner>;
}
/**
 * 
 * @export
 * @interface CreateNftRequestTokensInner
 */
export interface CreateNftRequestTokensInner {
    /**
     * Asset name. Take into consideration is the name is case sensitive and is between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof CreateNftRequestTokensInner
     */
    'asset_name': string;
    /**
     * Display name. Between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof CreateNftRequestTokensInner
     */
    'name': string;
    /**
     * Token description. Between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof CreateNftRequestTokensInner
     */
    'description'?: string;
    /**
     * (Optional) Individual NFT price in Lovelace (1 ADA = 1000000 Lovelace). This parameter is used for flash minting when you don\'t want to create Sale Phases or Sales and want to make a quick sale.
     * @type {number}
     * @memberof CreateNftRequestTokensInner
     */
    'price'?: number;
    /**
     * Media type. For example you can use `image/jpeg`, `image/png`, `image/gif`, `video/mp4`.
     * @type {string}
     * @memberof CreateNftRequestTokensInner
     */
    'media_type'?: string;
    /**
     * 
     * @type {CreateNftRequestTokensInnerImage}
     * @memberof CreateNftRequestTokensInner
     */
    'image': CreateNftRequestTokensInnerImage;
    /**
     * You have to specify the values for the tag attributes for every token as defined in the collection attribute tag definition when you create the collection. Please take into consideration that we have to define these values for every single NFT in the collection. For example, we set the colour, body, eyes, face and mime type for that particular NFT.For more details about Metadata have a look at the CIP (https://cips.cardano.org/cips/cip25/)
     * @type {Array<CreateNftRequestTokensInnerMetadataAttributesInner>}
     * @memberof CreateNftRequestTokensInner
     */
    'metadata_attributes'?: Array<CreateNftRequestTokensInnerMetadataAttributesInner>;
    /**
     * Here you can set any arbitrary attributes that you didn\'t include in the collection attributes tag definition. Use `\"key\":\"value\"` pairs to define unique attributes for each NFT.
     * @type {object}
     * @memberof CreateNftRequestTokensInner
     */
    'custom_attributes'?: object;
}
/**
 * @type CreateNftRequestTokensInnerImage
 * base64 encoded image.
 * @export
 */
export type CreateNftRequestTokensInnerImage = Array<string> | string;

/**
 * 
 * @export
 * @interface CreateNftRequestTokensInnerMetadataAttributesInner
 */
export interface CreateNftRequestTokensInnerMetadataAttributesInner {
    /**
     * Use the `tag` to match the tag defined in the collection.
     * @type {string}
     * @memberof CreateNftRequestTokensInnerMetadataAttributesInner
     */
    'tag'?: string;
    /**
     * Use the `value` to set a value for the tag `tag`.
     * @type {string}
     * @memberof CreateNftRequestTokensInnerMetadataAttributesInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface CreateNftResponse
 */
export interface CreateNftResponse {
    /**
     * 
     * @type {Array<Token>}
     * @memberof CreateNftResponse
     */
    'data'?: Array<Token>;
    /**
     * 
     * @type {number}
     * @memberof CreateNftResponse
     */
    'status_code'?: number;
}
/**
 * 
 * @export
 * @interface CreateNftSaleRequest
 */
export interface CreateNftSaleRequest {
    /**
     * <br /> Use `fixed` for selling a particular token or token list identified by the token-id.  <br /> Use `random` for random sales, it will pick random tokens from the collection.\' 
     * @type {string}
     * @memberof CreateNftSaleRequest
     */
    'type': CreateNftSaleRequestTypeEnum;
    /**
     * Individual NFT price in Lovelace (1 ADA = 1000000 Lovelace).
     * @type {number}
     * @memberof CreateNftSaleRequest
     */
    'price': number;
    /**
     * Reservation time in *seconds*. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, the NFT will be ready for sale again, and another buyer can reserve it.
     * @type {number}
     * @memberof CreateNftSaleRequest
     */
    'reservation_time': number;
    /**
     * An array of the token ids of the NFTs you want to sell. This field is required only for `fixed` sales. If you use `ramdom` sale you should omit this field.
     * @type {Array<string>}
     * @memberof CreateNftSaleRequest
     */
    'tokens'?: Array<string>;
    /**
     * Amount of tokens to sell.
     * @type {number}
     * @memberof CreateNftSaleRequest
     */
    'quantity'?: number;
}

export const CreateNftSaleRequestTypeEnum = {
    Fixed: 'fixed',
    Random: 'random'
} as const;

export type CreateNftSaleRequestTypeEnum = typeof CreateNftSaleRequestTypeEnum[keyof typeof CreateNftSaleRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateNftSaleResponse
 */
export interface CreateNftSaleResponse {
    /**
     * Sale id. This gives you a way to identify a particular sale. Every time you generate a sale you\'ll get a new sale id.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'id'?: string;
    /**
     * NFT status
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'status'?: CreateNftSaleResponseStatusEnum;
    /**
     * Use `fixed` for selling a particular token or token list identified by the token-id. Use `random` for random sales, it will pick random tokens from the collection.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'type'?: CreateNftSaleResponseTypeEnum;
    /**
     * Individual token price in Lovelace (1 ADA = 1000000 Lovelace).
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'price'?: number;
    /**
     * Number of tokens for sale. 1 for NFTs.
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'supply'?: number;
    /**
     * Address where the customer has to make the payment.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'payment_address'?: string;
    /**
     * Reservation time in ms. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received, and this timer expires then the NFT is ready for sale again and it can be reserved by another buyer.
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'reserved_time'?: number;
    /**
     * Payment URL. This is the URL you add to your website as a link or a button to buy the NFTs. You can think about this URL as your payment button.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'payment_link'?: string;
    /**
     * Tangocrypto fee per NFT minted.
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'service_fee'?: number;
    /**
     * Array of NFTs. The metadata is shown with the same format that is minted.
     * @type {Array<object>}
     * @memberof CreateNftSaleResponse
     */
    'tokens'?: Array<object>;
    /**
     * number of confirmations.
     * @type {number}
     * @memberof CreateNftSaleResponse
     */
    'confirmations'?: number;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateNftSaleResponse
     */
    'updated_at'?: string;
}

export const CreateNftSaleResponseStatusEnum = {
    UploadingContent: 'UPLOADING_CONTENT',
    ForSale: 'FOR_SALE',
    Reserved: 'RESERVED',
    Completed: 'COMPLETED'
} as const;

export type CreateNftSaleResponseStatusEnum = typeof CreateNftSaleResponseStatusEnum[keyof typeof CreateNftSaleResponseStatusEnum];
export const CreateNftSaleResponseTypeEnum = {
    Fixed: 'fixed',
    Random: 'random'
} as const;

export type CreateNftSaleResponseTypeEnum = typeof CreateNftSaleResponseTypeEnum[keyof typeof CreateNftSaleResponseTypeEnum];

/**
 * 
 * @export
 * @interface CreatePriceTierItem
 */
export interface CreatePriceTierItem {
    /**
     * Price tier ID.
     * @type {string}
     * @memberof CreatePriceTierItem
     */
    'id'?: string;
    /**
     * Price tier name
     * @type {string}
     * @memberof CreatePriceTierItem
     */
    'name'?: string;
    /**
     * Price (in Lovelaces) for the tier. For example, you can create a price tier with amount 5 and price 50. That means the buyer is going to pay 50 ADA for 5 NFTs.
     * @type {number}
     * @memberof CreatePriceTierItem
     */
    'price'?: number;
    /**
     * Amount of tokens to mint in a price tier. For example, you can specify that buyers selecting the bronze price tier will mint 1 token and the buyers choosing the silver price tier will mint 5 tokens.
     * @type {number}
     * @memberof CreatePriceTierItem
     */
    'count'?: number;
    /**
     * Token supply. If you don\'\'t specify the supply, it will be set to 1 by default.
     * @type {number}
     * @memberof CreatePriceTierItem
     */
    'supply'?: number;
    /**
     * Amount of tokens sold with the price tier.
     * @type {number}
     * @memberof CreatePriceTierItem
     */
    'token_sold_count'?: number;
    /**
     * Payment URL. This is the URL you add to your website as a link or a button to buy the NFTs. You can think about this URL as your payment button.
     * @type {string}
     * @memberof CreatePriceTierItem
     */
    'payment_link'?: string;
}

/**
 * 
 * @export
 * @interface CreateSalePhaseRequest
 */
export interface CreateSalePhaseRequest {
    /**
     * Sale phase name. For example, pre-sale.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'name'?: string;
    /**
     * <br /> Use `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> Use `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'type': CreateSalePhaseRequestTypeEnum;
    /**
     * Sale active. 
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'active'?: boolean;
    /**
     * Defines how many NFTs you will sell in this phase. For example, you are doing a pre-sale, and you want to sell 1000 NFTs.
     * @type {number}
     * @memberof CreateSalePhaseRequest
     */
    'total_tokens': number;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {number}
     * @memberof CreateSalePhaseRequest
     */
    'reservation_time'?: number;
    /**
     * Starting date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don\'t provide this value you can start selling immediately.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'start_date'?: string;
    /**
     * Ending date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don\'t provide this value, there is no time boundary; thus, you can sell NFTs until you reach the collection\'s total amount.
     * @type {string}
     * @memberof CreateSalePhaseRequest
     */
    'end_date'?: string;
    /**
     * (Used in `random` sale phases). Create price tiers per sale phase. A price tier is a way to create bundles and sell them for different prices. For example, you can create a price tier with 10 NFTs for 100 ADA, and the buyer will pay 100 ADA and receive 10 NFTs in their wallet. You can create up to 10 price tiers per sale phase.\'
     * @type {Array<CreateSalePhaseRequestPriceTiersInner>}
     * @memberof CreateSalePhaseRequest
     */
    'price_tiers'?: Array<CreateSalePhaseRequestPriceTiersInner>;
    /**
     * (Used in `fixed` sale phases). Individual tokens to include in a sale phase.
     * @type {Array<CreateSalePhaseRequestTokensInner>}
     * @memberof CreateSalePhaseRequest
     */
    'tokens'?: Array<CreateSalePhaseRequestTokensInner>;
}

/**
 * 
 * @export
 * @interface UpdateSalePhaseRequest
 */
export interface UpdateSalePhaseRequest {
    /**
     * Sale phase name. For example, pre-sale.
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'name'?: string;
    /**
     * <br /> Use `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> Use `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'type'?: CreateSalePhaseRequestTypeEnum;
    /**
     * Sale active. 
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'active'?: boolean;
    /**
     * Defines how many NFTs you will sell in this phase. For example, you are doing a pre-sale, and you want to sell 1000 NFTs.
     * @type {number}
     * @memberof UpdateSalePhaseRequest
     */
    'total_tokens': number;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {number}
     * @memberof UpdateSalePhaseRequest
     */
    'reservation_time'?: number;
    /**
     * Starting date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don\'t provide this value you can start selling immediately.
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'start_date'?: string;
    /**
     * Ending date for the sale phase in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. If you don\'t provide this value, there is no time boundary; thus, you can sell NFTs until you reach the collection\'s total amount.
     * @type {string}
     * @memberof UpdateSalePhaseRequest
     */
    'end_date'?: string;
    /**
     * (Used in `random` sale phases). Create price tiers per sale phase. A price tier is a way to create bundles and sell them for different prices. For example, you can create a price tier with 10 NFTs for 100 ADA, and the buyer will pay 100 ADA and receive 10 NFTs in their wallet. You can create up to 10 price tiers per sale phase.\'
     * @type {Array<CreateSalePhaseRequestPriceTiersInner>}
     * @memberof UpdateSalePhaseRequest
     */
    'price_tiers'?: Array<CreateSalePhaseRequestPriceTiersInner>;
    /**
     * (Used in `fixed` sale phases). Individual tokens to include in a sale phase.
     * @type {Array<CreateSalePhaseRequestTokensInner>}
     * @memberof UpdateSalePhaseRequest
     */
    'tokens'?: Array<CreateSalePhaseRequestTokensInner>;
}

export const CreateSalePhaseRequestTypeEnum = {
    Fixed: 'fixed',
    Random: 'random'
} as const;

export type CreateSalePhaseRequestTypeEnum = typeof CreateSalePhaseRequestTypeEnum[keyof typeof CreateSalePhaseRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateSalePhaseRequestPriceTiersInner
 */
export interface CreateSalePhaseRequestPriceTiersInner {
    /**
     * Price tier name. You can name your price tiers within a sale phase.
     * @type {string}
     * @memberof CreateSalePhaseRequestPriceTiersInner
     */
    'name'?: string;
    /**
     * Amount of tokens to mint in a price tier. For example, you can specify that buyers selecting the bronze price tier will mint 1 token and the buyers choosing the silver price tier will mint a bundle with 5 tokens. You can create a price tier with a maximum of 100 tokens.
     * @type {number}
     * @memberof CreateSalePhaseRequestPriceTiersInner
     */
    'quantity': number;
    /**
     * Token supply. If you don\'\'t specify the supply, it will be set to 1 by default.
     * @type {number}
     * @memberof CreateSalePhaseRequestPriceTiersInner
     */
    'supply'?: number;
    /**
     * Price (in Lovelaces) for the tier. For example, you can create a price tier with amount 5 and price 50. That means the buyer is going to pay 50 ADA for 5 NFTs.
     * @type {number}
     * @memberof CreateSalePhaseRequestPriceTiersInner
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface CreateSalePhaseRequestTokensInner
 */
export interface CreateSalePhaseRequestTokensInner {
    /**
     * Token id. This id is returned when you create the tokens.
     * @type {string}
     * @memberof CreateSalePhaseRequestTokensInner
     */
    'id': string;
    /**
     * Token supply. If you don\'\'t specify the supply, it will be set to 1 by default.
     * @type {number}
     * @memberof CreateSalePhaseRequestTokensInner
     */
    'supply'?: number;
    /**
     * Price (in Lovelaces) for the token.
     * @type {number}
     * @memberof CreateSalePhaseRequestTokensInner
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface CreateSalePhaseResponse
 */
export interface CreateSalePhaseResponse {
    /**
     * Sale phase ID. Use this ID to identify different phases.
     * @type {string}
     * @memberof CreateSalePhaseResponse
     */
    'id'?: string;
    /**
     * <br /> `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof CreateSalePhaseResponse
     */
    'type'?: string;
    /**
     * True if the sale phase is active, false if is not active.
     * @type {boolean}
     * @memberof CreateSalePhaseResponse
     */
    'active'?: boolean;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {number}
     * @memberof CreateSalePhaseResponse
     */
    'reservation_time'?: number;
    /**
     * Total amount of tokens for sell in the phase.
     * @type {number}
     * @memberof CreateSalePhaseResponse
     */
    'total_tokens'?: number;
    /**
     * Remaining tokens for sale.
     * @type {number}
     * @memberof CreateSalePhaseResponse
     */
    'remaining_tokens'?: number;
    /**
     * 
     * @type {Array<CreatePriceTierItem>}
     * @memberof CreateSalePhaseResponse
     */
    'price_tiers'?: Array<CreatePriceTierItem>;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateSalePhaseResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof CreateSalePhaseResponse
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @interface DeleteAddressListResponse
 */
 export interface DeleteAddressListResponse {
    /**
     * Returns `true` if was succesfully deleted or `false` if there was an error.
     * @type {boolean}
     * @memberof DeleteAddressListResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted address list id
     * @type {string}
     * @memberof DeleteAddressListResponse
     */
    'deleted_phase_id'?: string;
    /**
     * Timestamp of this deletion in ISO 8601 format.
     * @type {string}
     * @memberof DeleteAddressListResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface DeleteAffiliateResponse
 */
export interface DeleteAffiliateResponse {
    /**
     * Returns `true` if successfuly deleted or `false` if there was an error deleting the affiliate.
     * @type {boolean}
     * @memberof DeleteAffiliateResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted affiliate ID
     * @type {string}
     * @memberof DeleteAffiliateResponse
     */
    'deleted_affiliate_id'?: string;
    /**
     * Deletion datetime in ISO 8601 format.
     * @type {string}
     * @memberof DeleteAffiliateResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface DeleteNftResponse
 */
export interface DeleteNftResponse {
    /**
     * Returns `true` if successfuly deleted or `false` if there was an error deleting the token.
     * @type {boolean}
     * @memberof DeleteNftResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted token ID
     * @type {string}
     * @memberof DeleteNftResponse
     */
    'deleted_token_id'?: string;
    /**
     * Deletion datetime in ISO 8601 format.
     * @type {string}
     * @memberof DeleteNftResponse
     */
    'deleted_at'?: string;
}
/**
 * 
 * @export
 * @interface DeleteSalePhaseResponse
 */
export interface DeleteSalePhaseResponse {
    /**
     * Returns `true` if was succesfully deleted or `false` if there was an error.
     * @type {boolean}
     * @memberof DeleteSalePhaseResponse
     */
    'deleted'?: boolean;
    /**
     * Deleted sale phase id
     * @type {string}
     * @memberof DeleteSalePhaseResponse
     */
    'deleted_phase_id'?: string;
    /**
     * Timestamp of this deletion in ISO 8601 format.
     * @type {string}
     * @memberof DeleteSalePhaseResponse
     */
    'deleted_at'?: string;
}

/**
 * 
 * @export
 * @interface AddressList
 */
export interface AddressList {
    /**
     * Address list id.
     * @type {string}
     * @memberof AddressList
     */
    'id'?: string;
    /**
     * Address list name.
     * @type {string}
     * @memberof AddressList
     */
    'name'?: string;
    /**
     * Address list description.
     * @type {string}
     * @memberof AddressList
     */
    'description'?: string;
    /**
     * Size in bytes.
     * @type {number}
     * @memberof AddressList
     */
    'size'?: number;
    /**
     * Number of addressess in the list.
     * @type {number}
     * @memberof AddressList
     */
    'items'?: number;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof AddressList
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof AddressList
     */
    'updated_at'?: string;
}

/**
 * 
 * @export
 * @interface Sale
 */
export interface Sale {
    /**
     * Sale id. This gives you a way to identify a particular sale. Every time you generate a sale you\'ll get a new sale id.
     * @type {string}
     * @memberof Sale
     */
    'id'?: string;
    /**
     * NFT status
     * @type {string}
     * @memberof Sale
     */
    'status'?: string;
    /**
     * `fixed` for selling a particular token or token list identified by the token-id. `random` for random sales, it will pick random tokens from the collection.
     * @type {string}
     * @memberof Sale
     */
    'type'?: string;
    /**
     * Individual token price in Lovelace (1 ADA = 1000000 Lovelace).
     * @type {number}
     * @memberof Sale
     */
    'price'?: number;
    /**
     * Amount of ADA received from the sale. This amount goes to the payout wallet defined in the collection.
     * @type {number}
     * @memberof Sale
     */
    'income'?: number;
    /**
     * Number of tokens for sale. 1 for NFTs.
     * @type {number}
     * @memberof Sale
     */
    'supply'?: number;
    /**
     * Address where the customer has to make the payment.
     * @type {string}
     * @memberof Sale
     */
    'payment_address'?: string;
    /**
     * Reservation time in ms. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received, and this timer expires then the NFT is ready for sale again and it can be reserved by another buyer.
     * @type {number}
     * @memberof Sale
     */
    'reserved_time'?: number;
    /**
     * Tangocrypto fee per NFT minted.
     * @type {number}
     * @memberof Sale
     */
    'service_fee'?: number;
    /**
     * Array of NFTs. The metadata is shown with the same format that is minted.
     * @type {Array<object>}
     * @memberof Sale
     */
    'tokens'?: Array<object>;
    /**
     * Transaction ID where the NFT was minted. This field is returned only when the status is `COMPLETED.`
     * @type {string}
     * @memberof Sale
     */
    'tx_id'?: string;
    /**
     * transaction fee
     * @type {number}
     * @memberof Sale
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof Sale
     */
    'nft_fee'?: number;
    /**
     * number of confirmations.
     * @type {number}
     * @memberof Sale
     */
    'confirmations'?: number;
    /**
     * Phase id if the NFT is included in a sale phase.
     * @type {string}
     * @memberof Sale
     */
    'phase_id'?: string;
    /**
     * Price tier ID.
     * @type {string}
     * @memberof Sale
     */
    'price_tier_id'?: string;
    /**
     * 
     * @type {RetrieveNftSaleResponseAffiliate}
     * @memberof Sale
     */
    'affiliate'?: RetrieveNftSaleResponseAffiliate;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof Sale
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof Sale
     */
    'updated_at'?: string;
}

/**
 * 
 * @export
 * @interface SalePhase
 */
export interface SalePhase {
    /**
     * Sales phase ID.
     * @type {string}
     * @memberof SalePhase
     */
    'id'?: string;
    /**
     * <br /> `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof SalePhase
     */
    'type'?: string;
    /**
     * True if the sale phase is active, false if is not active.
     * @type {boolean}
     * @memberof SalePhase
     */
    'active'?: boolean;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {string}
     * @memberof SalePhase
     */
    'reservation_time'?: string;
    /**
     * Total amount of tokens for sell in the phase.
     * @type {string}
     * @memberof SalePhase
     */
    'total_tokens'?: string;
    /**
     * Remaining tokens for sale.
     * @type {string}
     * @memberof SalePhase
     */
    'remaining_tokens'?: string;
    /**
     * A price tier is a way to create bundles and sell them for different prices. For example, you can create a price tier with 10 NFTs for 100 ADA, and the buyer will pay 100 ADA and receive 10 NFTs in their wallet.
     * @type {Array<PriceTierItem>}
     * @memberof SalePhase
     */
    'price_tiers'?: Array<PriceTierItem>;
    /**
     * Affiliate summary data. This array is shown only if the sale phase has an affiliate program (optional).
     * @type {Array<AffiliateSummary>}
     * @memberof SalePhase
     */
    'affiliates'?: Array<AffiliateSummary>;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof SalePhase
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof SalePhase
     */
    'updated_at'?: string;
}
/**
 * NFT Collection
 * @export
 * @interface Collection
 */
 export interface Collection {
    /**
     * Collection ID.
     * @type {string}
     * @memberof Collection
     */
    'id'?: string;
    /**
     * Collection name.
     * @type {string}
     * @memberof Collection
     */
    'name'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof Collection
     */
    'url'?: string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof Collection
     */
    'description'?: string;
    /**
     * 
     * @type {NftCollectionPayoutAddress}
     * @memberof Collection
     */
    'payout_address'?: NftCollectionPayoutAddress;
    /**
     * Amount of tokens in the collection.
     * @type {number}
     * @memberof Collection
     */
    'token_count'?: number;
    /**
     * Amount of tokens for sale.
     * @type {number}
     * @memberof Collection
     */
    'token_for_sale_count'?: number;
    /**
     * Amount of tokens sold.
     * @type {number}
     * @memberof Collection
     */
    'token_sold_count'?: number;
    /**
     * The total amount of ADA generated by the sale of NFTs in the collection. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {number}
     * @memberof Collection
     */
    'revenue'?: number;
    /**
     * The total amount of ADA generated by the sale of NFTs that goest to the seller.
     * @type {number}
     * @memberof Collection
     */
    'income'?: number;
    /**
     * Tangocrypto service fee. This fee depends on your plan and the number of NFTs minted. Check the price page to get more information about it.
     * @type {number}
     * @memberof Collection
     */
    'service_fee'?: number;
    /**
     * Total commission paid to affiliates (in Lovelaces). If there are no affiliates, this value is 0.
     * @type {number}
     * @memberof Collection
     */
    'affiliate_commission'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof Collection
     */
    'nft_fee'?: number;
    /**
     * Transaction fees.
     * @type {number}
     * @memberof Collection
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent in fees. This includes transaction fees, nft fees and the service fees.
     * @type {number}
     * @memberof Collection
     */
    'total_fees'?: number;
    /**
     * 
     * @type {NftCollectionPolicy}
     * @memberof Collection
     */
    'policy'?: NftCollectionPolicy;
    /**
     * 
     * @type {NftCollectionMetadata}
     * @memberof Collection
     */
    'metadata'?: NftCollectionMetadata;
    /**
     * 
     * @type {NftCollectionRoyalty}
     * @memberof Collection
     */
    'royalty'?: NftCollectionRoyalty;
    /**
     * 
     * @type {NftCollectionRoyaltySaleInfo}
     * @memberof Collection
     */
    'royalty_sale_info'?: NftCollectionRoyaltySaleInfo;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof Collection
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof Collection
     */
    'updated_at'?: string;
}
/**
 * Metadata tags for the collection. The values between `< >` mean that they are tags. A tag is simply a variable that we will evaluate its value when you mint the NFT. You can use the metadata tag to define common attributes shared by all the NFTs in the collection, like the name, copyright, date issued, artist name, social media links, etc. Using metadata tags is not mandatory because you can define all the attributes while creating the individual NFTs. 
 * @export
 * @interface NftCollectionMetadata
 */
export interface NftCollectionMetadata {
    /**
     * Metadata label. In Cardano NFTs are identified by the `721` label.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'label'?: string;
    /**
     * Metadata tag for the NFT name.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'asset_name'?: string;
    /**
     * Metadata tag for the NFT asset name.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'name'?: string;
    /**
     * Metadata tag for the NFT image link.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'image'?: string;
    /**
     * Metadata tag for the media type (also known as a Multipurpose Internet Mail Extensions or MIME type) indicates the nature and format of a document, file, or assortment of bytes. It is common to have NFTs with MIME-type imag, audioand video.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'media_type'?: string;
    /**
     * Metadata tag for the NFT image link.
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'description'?: string;
    /**
     * Array of files used for files. This is used when you want to create an NFT with different file formats. For example, you can create several audio files and add them to the metadata.
     * @type {Array<NftCollectionMetadataFilesInner>}
     * @memberof NftCollectionMetadata
     */
    'files'?: Array<NftCollectionMetadataFilesInner>;
    /**
     * Custom attributes or traits for an NFT. You can create 2 types of attributes, fixed or variables. **Fixed**: We include these attributes in the metadata of every NFT minted in the collection with a fixed value. You can add attributes like artist name, Twitter, Discord, copyright etc. You define their value here, and then you don\'t have to submit them during the NFT creation step. **Variables**: Here you set a tag value, and we evaluate variables attributes during the NFT creation step. As you can see in the example, we defined five traits (colour, body, eyes, face, and accessories), but we don\'t specify the value, just a tag between `<>`. 
     * @type {object}
     * @memberof NftCollectionMetadata
     */
    'attributes'?: object;
    /**
     * CIP 25 - NFT Metadata Standard Version
     * @type {string}
     * @memberof NftCollectionMetadata
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface NftCollectionMetadataFilesInner
 */
export interface NftCollectionMetadataFilesInner {
    /**
     * Asset name of the file
     * @type {string}
     * @memberof NftCollectionMetadataFilesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NftCollectionMetadataFilesInner
     */
    'media_type'?: string;
    /**
     * same as the previous description.
     * @type {string}
     * @memberof NftCollectionMetadataFilesInner
     */
    'src'?: string;
}
/**
 * @type NftCollectionPayoutAddress
 * @export
 */
export type NftCollectionPayoutAddress = Array<NftCollectionPayoutAddressOneOfInner> | string;

/**
 * 
 * @export
 * @interface NftCollectionPayoutAddressOneOfInner
 */
export interface NftCollectionPayoutAddressOneOfInner {
    /**
     * Wallet address that is going to receive a percentage payments of the NFT sale.
     * @type {string}
     * @memberof NftCollectionPayoutAddressOneOfInner
     */
    'addr'?: string;
    /**
     * Wallet name. This is used to identify the wallet.
     * @type {string}
     * @memberof NftCollectionPayoutAddressOneOfInner
     */
    'name'?: string;
    /**
     * Percentage of the sale price earned each time your NFT creation is sold. For example, 0.05 represents 5%.
     * @type {number}
     * @memberof NftCollectionPayoutAddressOneOfInner
     */
    'ratio'?: number;
}
/**
 * 
 * @export
 * @interface NftCollectionPolicy
 */
export interface NftCollectionPolicy {
    /**
     * Defines if the policy will be locked or not. You are not required to chose a date and time to lock the policy, if you set this parameter to false it means that the policy will be open and you can be minting NFTs under this policy forever. If you set this parameter to true then you have to specify a locktime date.
     * @type {boolean}
     * @memberof NftCollectionPolicy
     */
    'lock'?: boolean;
    /**
     * Locktime date in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. It defines how long you\'ll be able to mint NFTs for the collection. The policy will lock after that date, and you won\'t be able to mint more NFTs using the same policy id (even if you use the same key). Hours and minutes are optional; if you set it to `2022-02-24`, it will automatically fill it with 0s, for example, `2022-02-24T00:00:00.000Z`. Take into consideration the desirability and size of your collection before setting this date and leave enough time for selling the NFTs. There is no limited time for the future. 
     * @type {string}
     * @memberof NftCollectionPolicy
     */
    'lock_time'?: string;
    /**
     * Policy ID of the collection. You should post the policy ID in you website, social media or any communication channel you use for buyers to verify the authenticity of the tokens they buy.
     * @type {string}
     * @memberof NftCollectionPolicy
     */
    'policy_id'?: string;
    /**
     * 
     * @type {PolicyScript}
     * @memberof NftCollectionPolicy
     */
    'script'?: PolicyScript;
}
/**
 * 
 * @export
 * @interface NftCollectionRoyalty
 */
export interface NftCollectionRoyalty {
    /**
     * 
     * @type {NftCollectionRoyaltyMetadata}
     * @memberof NftCollectionRoyalty
     */
    'metadata'?: NftCollectionRoyaltyMetadata;
}
/**
 * 
 * @export
 * @interface NftCollectionRoyaltyMetadata
 */
export interface NftCollectionRoyaltyMetadata {
    /**
     * 
     * @type {NftCollectionRoyaltyMetadata777}
     * @memberof NftCollectionRoyaltyMetadata
     */
    '777'?: NftCollectionRoyaltyMetadata777;
}
/**
 * 
 * @export
 * @interface NftCollectionRoyaltyMetadata777
 */
export interface NftCollectionRoyaltyMetadata777 {
    /**
     * Bech32 address split in a two-element array. Each element in the array must have up to 64 bytes.
     * @type {Array<string>}
     * @memberof NftCollectionRoyaltyMetadata777
     */
    'addr'?: Array<string>;
    /**
     * Percentage of the sale price earned each time your NFT creation is sold on a marketplace. For example, 0.05 represents 5%.
     * @type {string}
     * @memberof NftCollectionRoyaltyMetadata777
     */
    'rate'?: string;
}
/**
 * 
 * @export
 * @interface NftCollectionRoyaltySaleInfo
 */
export interface NftCollectionRoyaltySaleInfo {
    /**
     * Sale id where the royalty token was minted.
     * @type {string}
     * @memberof NftCollectionRoyaltySaleInfo
     */
    'sale_id'?: string;
    /**
     * Transaction Id where the royalty token was minted.
     * @type {string}
     * @memberof NftCollectionRoyaltySaleInfo
     */
    'tx_id'?: string;
    /**
     * Amount of Ada spent on fees minting the royalty token.
     * @type {number}
     * @memberof NftCollectionRoyaltySaleInfo
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof NftCollectionRoyaltySaleInfo
     */
    'nft_fee'?: number;
}
/**
 * 
 * @export
 * @interface NftCollectionSummary
 */
export interface NftCollectionSummary {
    /**
     * Collection ID.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'id'?: string;
    /**
     * Collection name.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'name'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'url'?: string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'description'?: string;
    /**
     * Amount of tokens in the collection.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'token_count'?: string;
    /**
     * Amount of tokens for sale.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'token_for_sale_count'?: string;
    /**
     * Amount of tokens sold.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'token_sold_count'?: string;
    /**
     * The total amount of ADA generated by the sale of NFTs in the collection. This number represents gross sales; it doesn\'t include any fee deduction.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'revenue'?: string;
    /**
     * Tangocrypto service fee. This fee depends on your plan and the number of NFTs minted. Check the price page to get more information about it.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'service_fee'?: string;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'nft_fee'?: string;
    /**
     * Transaction fees.
     * @type {string}
     * @memberof NftCollectionSummary
     */
    'tx_fee'?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * NFT id. This id is within your Tangocrypto account.
     * @type {string}
     * @memberof Token
     */
    'id'?: string;
    /**
     * asset name
     * @type {string}
     * @memberof Token
     */
    'asset_name'?: string;
    /**
     * name
     * @type {string}
     * @memberof Token
     */
    'name'?: string;
    /**
     * The CIP14 fingerprint for the Multi-Asset.
     * @type {string}
     * @memberof Token
     */
    'fingerprint'?: string;
    /**
     * There are several states for the tokens `UPLOADING_CONTENT`, `FOR_SALE`, `RESERVED`, `CANCELED`, `COMPLETED`, `EXPIRED`
     * @type {string}
     * @memberof Token
     */
    'status'?: string;
    /**
     * Individual token price in Lovelace (1 ADA = 1000000 Lovelace). This field is available when the token is created with the `price`.
     * @type {number}
     * @memberof Token
     */
    'price'?: number;
    /**
     * Payment URL. This is the URL you add to your website as a link or a button to buy the NFTs. You can think about this URL as your payment button. This field is available when the token is created with the `price`.
     * @type {string}
     * @memberof Token
     */
    'payment_link'?: string;
    /**
     * Token description.
     * @type {string}
     * @memberof Token
     */
    'description'?: string;
    /**
     * Link to IPFS image, for example, \"ipfs://QmZHWcx7afrxuvcqeqntZtfv93c2VciBWjyi9LCwUEKZmx\"
     * @type {string}
     * @memberof Token
     */
    'image'?: string;
    /**
     * the description
     * @type {string}
     * @memberof Token
     */
    'media_type'?: string;
    /**
     * Metadata attributes tag definition. The tag values are matched with the collection tags
     * @type {object}
     * @memberof Token
     */
    'metadata_attributes'?: object;
    /**
     * Any arbitrary attributes that you didn\'t include in the collection attributes placeholder definition. Use key-value pairs to define unique attributes for each NFT.
     * @type {object}
     * @memberof Token
     */
    'custom_attributes'?: object;
    /**
     * 
     * @type {NftTokenPolicy}
     * @memberof Token
     */
    'policy'?: NftTokenPolicy;
    /**
     * NFT Metadata. Here you can see exactly how the metadata will look like once the NFT is minted.
     * @type {object}
     * @memberof Token
     */
    'metadata'?: object;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof Token
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {number}
     * @memberof Token
     */
    'updated_at'?: number;
}
/**
 * 
 * @export
 * @interface NftTokenPolicy
 */
export interface NftTokenPolicy {
    /**
     * Defines if the policy will be locked or not. If you select falsethen you are not required to choose a date and time to lock the policy, therefore the policy will be open and you can be minting NFTs under this policy forever.  If you set this parameter to true then you have to specify a locktime date.
     * @type {boolean}
     * @memberof NftTokenPolicy
     */
    'lock'?: boolean;
    /**
     * Locktime date in ISO 8601 format `yyyy-mm-ddThh:mm:ss[.mmm]`. It defines how long you\'ll be able to mint NFTs for the collection. The policy will lock after that date, and you won\'t be able to mint more NFTs using the same policy id (even if you use the same key). Hours and minutes are optional; if you set it to `2022-02-24`, it will automatically fill it with 0s, for example, `2022-02-24T00:00:00.000Z`. Take into consideration the desirability and size of your collection before setting this date and leave enough time for selling the NFTs. There is no limited time for the future. 
     * @type {string}
     * @memberof NftTokenPolicy
     */
    'lock_time'?: string;
    /**
     * Cardano NFTs need to be identified by the policy id. This id is unique and attached permanently to the asset.
     * @type {string}
     * @memberof NftTokenPolicy
     */
    'policy_id'?: string;
    /**
     * 
     * @type {PolicyScript}
     * @memberof NftTokenPolicy
     */
    'script'?: PolicyScript;
}
/**
 * 
 * @export
 * @interface PolicyScript
 */
export interface PolicyScript {
    /**
     * 
     * @type {string}
     * @memberof PolicyScript
     */
    'type'?: string;
    /**
     * 
     * @type {Array<PolicyScriptScriptsInner>}
     * @memberof PolicyScript
     */
    'scripts'?: Array<PolicyScriptScriptsInner>;
}
/**
 * 
 * @export
 * @interface PolicyScriptScriptsInner
 */
export interface PolicyScriptScriptsInner {
    /**
     * 
     * @type {string}
     * @memberof PolicyScriptScriptsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyScriptScriptsInner
     */
    'keyHash'?: string;
    /**
     * 
     * @type {number}
     * @memberof PolicyScriptScriptsInner
     */
    'slot'?: number;
}
/**
 * 
 * @export
 * @interface PriceTierItem
 */
export interface PriceTierItem {
    /**
     * Price tier ID.
     * @type {string}
     * @memberof PriceTierItem
     */
    'id'?: string;
    /**
     * Price tier name
     * @type {string}
     * @memberof PriceTierItem
     */
    'name'?: string;
    /**
     * Price (in Lovelaces) for the tier. For example, you can create a price tier with amount 5 and price 50. That means the buyer is going to pay 50 ADA for 5 NFTs.
     * @type {number}
     * @memberof PriceTierItem
     */
    'price'?: number;
    /**
     * Amount of tokens to mint in a price tier. For example, you can specify that buyers selecting the bronze price tier will mint 1 token and the buyers choosing the silver price tier will mint 5 tokens.
     * @type {number}
     * @memberof PriceTierItem
     */
    'count'?: number;
    /**
     * Token supply. If you don\'\'t specify the supply, it will be set to 1 by default.
     * @type {number}
     * @memberof PriceTierItem
     */
    'supply'?: number;
    /**
     * Amount of tokens sold with the price tier.
     * @type {number}
     * @memberof PriceTierItem
     */
    'token_sold_count'?: number;
    /**
     * Payment URL. This is the URL you add to your website as a link or a button to buy the NFTs. You can think about this URL as your payment button.
     * @type {string}
     * @memberof PriceTierItem
     */
    'payment_link'?: string;
    /**
     * Affiliate summary data. This array is shown only if the sale phase has an affiliate program (optional).
     * @type {Array<PriceTierItemAffiliatesInner>}
     * @memberof PriceTierItem
     */
    'affiliates'?: Array<PriceTierItemAffiliatesInner>;
}
/**
 * 
 * @export
 * @interface PriceTierItemAffiliatesInner
 */
export interface PriceTierItemAffiliatesInner {
    /**
     * Affiliate id.
     * @type {string}
     * @memberof PriceTierItemAffiliatesInner
     */
    'id'?: string;
    /**
     * Payment link. This is the link that your affiliate has to share with their audience for them to purchase NFTs.
     * @type {string}
     * @memberof PriceTierItemAffiliatesInner
     */
    'payment_link'?: string;
    /**
     * Affiliate name. Used to identify the affiliate.
     * @type {string}
     * @memberof PriceTierItemAffiliatesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveAddressListResponse
 */
export interface RetrieveAddressListResponse {
    /**
     * 
     * @type {Array<RetrieveAddressListResponseDataInner>}
     * @memberof RetrieveAddressListResponse
     */
    'data'?: Array<RetrieveAddressListResponseDataInner>;
    /**
     * When the response is truncated, it includes a cursor that you can use in a subsequent request to retrieve the next set of invoices. If empty, this is the final response. For more information, see our <a href=\"https://docs.tangocrypto.com/rest-api/pagination\">pagination guide</a>. 
     * @type {string}
     * @memberof RetrieveAddressListResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveAddressListResponseDataInner
 */
export interface RetrieveAddressListResponseDataInner {
    /**
     * Address list id.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'name'?: string;
    /**
     * Address list name.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'description'?: string;
    /**
     * Size in bytes.
     * @type {number}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'size'?: number;
    /**
     * Number of items.
     * @type {number}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'items'?: number;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<RetrieveAddressListResponseDataInnerAddressesInner>}
     * @memberof RetrieveAddressListResponseDataInner
     */
    'addresses'?: Array<RetrieveAddressListResponseDataInnerAddressesInner>;
}
/**
 * 
 * @export
 * @interface RetrieveAddressListResponseDataInnerAddressesInner
 */
export interface RetrieveAddressListResponseDataInnerAddressesInner {
    /**
     * Cardano address.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInnerAddressesInner
     */
    'address'?: string;
    /**
     * Address notes. Here you can add a brief description of the address or add a date.
     * @type {string}
     * @memberof RetrieveAddressListResponseDataInnerAddressesInner
     */
    'notes'?: string;
}

/**
 * 
 * @export
 * @interface RetrieveNftSaleResponse
 */
export interface RetrieveNftSaleResponse {
    /**
     * Sale id. This gives you a way to identify a particular sale. Every time you generate a sale you\'ll get a new sale id.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'id'?: string;
    /**
     * NFT status
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'status'?: string;
    /**
     * `fixed` for selling a particular token or token list identified by the token-id. `random` for random sales, it will pick random tokens from the collection.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'type'?: string;
    /**
     * Individual token price in Lovelace (1 ADA = 1000000 Lovelace).
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'price'?: number;
    /**
     * Amount of ADA received from the sale. This amount goes to the payout wallet defined in the collection.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'income'?: number;
    /**
     * Number of tokens for sale. 1 for NFTs.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'supply'?: number;
    /**
     * Address where the customer has to make the payment.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'payment_address'?: string;
    /**
     * Reservation time in ms. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received, and this timer expires then the NFT is ready for sale again and it can be reserved by another buyer.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'reserved_time'?: number;
    /**
     * Tangocrypto fee per NFT minted.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'service_fee'?: number;
    /**
     * Array of NFTs. The metadata is shown with the same format that is minted.
     * @type {Array<object>}
     * @memberof RetrieveNftSaleResponse
     */
    'tokens'?: Array<object>;
    /**
     * Transaction ID where the NFT was minted. This field is returned only when the status is `COMPLETED.`
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'tx_id'?: string;
    /**
     * transaction fee
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'tx_fee'?: number;
    /**
     * Amount of ADA spent to send the NFTs to the buyer\'s wallets.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'nft_fee'?: number;
    /**
     * number of confirmations.
     * @type {number}
     * @memberof RetrieveNftSaleResponse
     */
    'confirmations'?: number;
    /**
     * Phase id if the NFT is included in a sale phase.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'phase_id'?: string;
    /**
     * 
     * @type {RetrieveNftSaleResponseAffiliate}
     * @memberof RetrieveNftSaleResponse
     */
    'affiliate'?: RetrieveNftSaleResponseAffiliate;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveNftSaleResponse
     */
    'updated_at'?: string;
}
/**
 * Optional property if the sale was made by an affiliate link.
 * @export
 * @interface RetrieveNftSaleResponseAffiliate
 */
export interface RetrieveNftSaleResponseAffiliate {
    /**
     * Affiliate id
     * @type {string}
     * @memberof RetrieveNftSaleResponseAffiliate
     */
    'id'?: string;
    /**
     * Affiliate name.
     * @type {string}
     * @memberof RetrieveNftSaleResponseAffiliate
     */
    'name'?: string;
    /**
     * Commission rate made by the affiliate (in Lovelaces).
     * @type {number}
     * @memberof RetrieveNftSaleResponseAffiliate
     */
    'commission'?: number;
}
/**
 * 
 * @export
 * @interface RetrieveSalePhaseResponse
 */
export interface RetrieveSalePhaseResponse {
    /**
     * Sales phase ID.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'id'?: string;
    /**
     * <br /> `fixed` for selling a particular token or token list identified by the token-id on each token.  <br /> `random` for random sales, it will pick random tokens from the collection. 
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'type'?: string;
    /**
     * True if the sale phase is active, false if is not active.
     * @type {boolean}
     * @memberof RetrieveSalePhaseResponse
     */
    'active'?: boolean;
    /**
     * Reservation time in seconds. This timer defines how long an NFT will be reserved once a potential buyer starts the buying process. During this time interval, the NFT won\'t be available for sale. No other buyer will be able to create a new reservation. If the payment is not received and this timer expires, then the NFT is ready for sale again, and it can be reserved by another buyer.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'reservation_time'?: string;
    /**
     * Total amount of tokens for sell in the phase.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'total_tokens'?: string;
    /**
     * Remaining tokens for sale.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'remaining_tokens'?: string;
    /**
     * 
     * @type {Array<PriceTierItem>}
     * @memberof RetrieveSalePhaseResponse
     */
    'price_tiers'?: Array<PriceTierItem>;
    /**
     * Affiliate summary data. This array is shown only if the sale phase has an affiliate program (optional).
     * @type {Array<AffiliateSummary>}
     * @memberof RetrieveSalePhaseResponse
     */
    'affiliates'?: Array<AffiliateSummary>;
    /**
     * Creation datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'created_at'?: string;
    /**
     * Update datetime in ISO 8601 format.
     * @type {string}
     * @memberof RetrieveSalePhaseResponse
     */
    'updated_at'?: string;
}
/**
 * Create NFT Collection request
 * @export
 * @interface UpdateCollectionRequest
 */
 export interface UpdateCollectionRequest {
    /**
     * Collection name. The collection name is internal to your Tangocrypto account. This is just a way to identify different collections.
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'name': string;
    /**
     * Collection description. The collection description is internal to your Tangocrypto account.
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'description'?: string;
    /**
     * URL of the website where the collection is going to be sold.
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'url'?: string;
    /**
     * Wallet address that is going to receive the payments of the NFT sale. This should be a wallet address of the seller.
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'payout_address': string;
    /**
     * 
     * @type {CreateCollectionRequestPolicy}
     * @memberof UpdateCollectionRequest
     */
    'policy': CreateCollectionRequestPolicy;
    /**
     * 
     * @type {UpdateCollectionRequestMetadata}
     * @memberof UpdateCollectionRequest
     */
    'metadata'?: UpdateCollectionRequestMetadata;
    /**
     * 
     * @type {NftCollectionRoyalty}
     * @memberof UpdateCollectionRequest
     */
    'royalty'?: NftCollectionRoyalty;
    /**
     * 
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    'payment_link'?: string;
}
/**
 * Metadata tags for the collection. The values between `< >` mean that they are tags. A tag is simply a variable that we will assign its value when you mint the NFT. You can use the metadata tag to define common attributes shared by all the NFTs in the collection, like the name, copyright, date issued, artist name, social media links, etc. Using metadata tags is not mandatory because you can define all the attributes while creating the individual NFTs. For more details about Metadata have a look at the CIP (https://cips.cardano.org/cips/cip25/) 
 * @export
 * @interface UpdateCollectionRequestMetadata
 */
export interface UpdateCollectionRequestMetadata {
    /**
     * Metadata tag for the NFT asset name.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'name': string;
    /**
     * Metadata tag for the NFT name.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'asset_name'?: string;
    /**
     * Metadata tag for the NFT description.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'description'?: string;
    /**
     * Metadata tag for the media type (also known as a Multipurpose Internet Mail Extensions or MIME type) indicates the nature and format of a document, file, or assortment of bytes. It is common to have NFTs with MIME-type imag, audioand video.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'media_type'?: string;
    /**
     * Metadata tag for the NFT image link.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'image'?: string;
    /**
     * Array of files used for files. This is used when you want to create an NFT with different file formats. For example, you can create several audio files and add them to the metadata.
     * @type {Array<UpdateCollectionRequestMetadataFilesInner>}
     * @memberof UpdateCollectionRequestMetadata
     */
    'files'?: Array<UpdateCollectionRequestMetadataFilesInner>;
    /**
     * Custom attributes or traits for an NFT. You can create 2 types of attributes, fixed or variables. **Fixed**: We include these attributes in the metadata of every NFT minted in the collection with a fixed value. You can add attributes like artist name, Twitter, Discord, copyright etc. You define their value here, and then you don\'t have to submit them during the NFT creation step. **Variables**: Here you set a tag value, and we evaluate variables attributes during the NFT creation step. As you can see in the example, we defined five traits (colour, body, eyes, face, and accessories), but we don\'t specify the value, just a tag between `<>`. 
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'attributes'?: string;
    /**
     * Metadata version
     * @type {string}
     * @memberof UpdateCollectionRequestMetadata
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCollectionRequestMetadataFilesInner
 */
export interface UpdateCollectionRequestMetadataFilesInner {
    /**
     * Asset name of the file
     * @type {string}
     * @memberof UpdateCollectionRequestMetadataFilesInner
     */
    'name'?: string;
    /**
     * same as the previous description.
     * @type {string}
     * @memberof UpdateCollectionRequestMetadataFilesInner
     */
    'media_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCollectionRequestMetadataFilesInner
     */
    'src'?: string;
}
/**
 * 
 * @export
 * @interface UpdateNftRequest
 */
export interface UpdateNftRequest {
    /**
     * Asset name. Take into consideration is the name is case sensitive and is between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'asset_name'?: string;
    /**
     * Display name. Between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'name'?: string;
    /**
     * Token description. Between 2 and 32 characters (maximum 64 bytes for UTF-8 encoded).
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'description'?: string;
    /**
     * (Optional) Individual NFT price in Lovelace (1 ADA = 1000000 Lovelace). This parameter is used for flash minting when you don\'t want to create Sale Phases or Sales and want to make a quick sale.
     * @type {number}
     * @memberof UpdateNftRequest
     */
    'price'?: number;
    /**
     * Media type. For example you can use `image/jpeg`, `image/png`, `image/gif`, `video/mp4`.
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'media_type'?: string;
    /**
     * base64 encoded image.
     * @type {string}
     * @memberof UpdateNftRequest
     */
    'image'?: string;
    /**
     * You have to specify the values for the tag attributes for every token as defined in the collection attribute tag definition when you create the collection. Please take into consideration that we have to define these values for every single NFT in the collection. For example, we set the colour, body, eyes, face and mime type for that particular NFT.For more details about Metadata have a look at the CIP (https://cips.cardano.org/cips/cip25/)
     * @type {Array<CreateNftRequestTokensInnerMetadataAttributesInner>}
     * @memberof UpdateNftRequest
     */
    'metadata_attributes'?: Array<CreateNftRequestTokensInnerMetadataAttributesInner>;
    /**
     * Here you can set any arbitrary attributes that you didn\'t include in the collection attributes tag definition. Use `\"key\":\"value\"` pairs to define unique attributes for each NFT.
     * @type {object}
     * @memberof UpdateNftRequest
     */
    'custom_attributes'?: object;
}